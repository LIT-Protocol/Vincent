{
	"id": 0,
	"name": "Vincent Docs",
	"variant": "project",
	"kind": 1,
	"flags": {},
	"documents": [
		{
			"id": 1,
			"name": "Why Vincent?",
			"variant": "document",
			"kind": 8388608,
			"flags": {},
			"content": [
				{
					"kind": "text",
					"text": "# Start Here\n\nVincent is an open-source framework powered by [Lit Protocol](https://litprotocol.com/) that empowers developers to create automated, user-controlled AI agents. With Vincent, you can build agents that automate the execution of operations across crypto networks, traditional finance (TradFi), and e-commerce platforms—all while ensuring users retain full control over their assets and data. Powered by Lit’s decentralized [key management network](https://developer.litprotocol.com/resources/how-it-works) and smart contracts, Vincent is your gateway to the future of the automated, User-Owned Web.\n\n[Demo](https://demo.heyvincent.ai/) |\n[Source Code](https://github.com/LIT-Protocol/vincent-dca/tree/main)\n\n## Why Vincent?\n\nVincent optimizes for security, interoperability, and user-control to redefine how agents interact across Web3 and beyond:\n\n- **Decentralized Key Management**: Vincent leverages Lit Protocol's [Programmable Key Pairs](https://developer.litprotocol.com/user-wallets/pkps/overview) (PKPs) to securely manage agent identities without exposing private keys.\n\n- **Verifiable, Fine-Grained Policies**: Users have full control over the policies they set and can revoke them at any time. Policies are fine-grained to specific operations and verifiable on-chain.\n\n- **Cross-Platform Automation**: With Vincent, agents can operate seamlessly across any blockchain or off-chain platform. Build agent-powered apps and tools for DeFi, TradFi, E-Commerce, and more.\n\n- **Agent Marketplace**: Vincent will eventually serve as a marketplace for Vincent-powered apps and tools, enabling them to be discovered and interacted with by end users.\n\n- **Open Source**: Fork, customize, and contribute to the [Vincent codebase](https://github.com/LIT-Protocol/Vincent) to shape the future of the agent-driven and user-controlled Web.\n\n## Get Started in Minutes\n\nIf you're a developer looking to deploy your first Vincent-enabled application or tool, head on over to the [quick start]("
				},
				{
					"kind": "relative-link",
					"text": "../docs/Developers/Quick-Start.md"
				},
				{
					"kind": "text",
					"text": ").\n\nIf you're looking to give Vincent a try as a user, check out the official demo showcasing [automated dollar-cost-averaging](https://demo.heyvincent.ai/).\n\n## Support\n\nIf you have any issues with the Vincent SDK, general questions about Vincent, or specific feature requests, please post them on the official [Vincent GitHub Repo](https://github.com/LIT-Protocol/Vincent/issues).\n\n## Join the Community\n\nWe want to hear from you! Join the [official Lit Protocol builders channel](https://t.me/c/2038294753/1) on Telegram to join the conversation and share your feedback.\n\nTo stay up to date on the latest updates, follow Lit on [X](https://x.com/LitProtocol)."
				}
			],
			"frontmatter": {
				"category": "Intro"
			}
		},
		{
			"id": 2,
			"name": "Concepts",
			"variant": "document",
			"kind": 8388608,
			"flags": {},
			"content": [
				{
					"kind": "text",
					"text": "Vincent is a platform that enables users to securely delegate on and off-chain operations (i.e. token swaps, buying and selling stocks, social media interactions) to AI agents and other permitted 3rd parties. Users have the ability to set fine-grained policies which govern how these operations are performed, ensuring they retain full control over how their assets and data are used. The Vincent platform is built on top of and secured by [Lit Protocol](https://developer.litprotocol.com/what-is-lit)\n\n> **Note:** The secure and non-custodial delegation of any on or off-chain actions is Vincent's core innovation. Vincent Users have the ability to delegate these operations to authorized 3rd parties (Vincent Apps and Agents) to execute on their behalf, while never giving up control of their assets and data. Vincent Apps can execute authorized Vincent Tools on behalf of a given user, but they can never access private keys or sign data outside of what the user has explicitly consented to.\n\nThis guide provides definitions of the core concepts of the Vincent platform, below is a quick overview of the concepts:\n\n| Concept Name                                                                     | Description                                                                                                                       | Example                                                                                                                    |\n| -------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n| Vincent Tool                                                                     | A function that enables Vincent Apps to perform specific actions on behalf of Vincent App Users                                   | A tool that executes token swaps on Uniswap or manages stock portfolios through a broker API                               |\n| Vincent Policy                                                                   | User-configured guardrails that control how Vincent Apps can use Vincent Tools                                                    | A daily spending limit of $1,000 or a requirement for 2FA on high-value transactions                                       |\n| Policy Parameters                                                                | On-chain configurable values that define how a Vincent Policy behaves for a specific Vincent App and User                         | A daily spending limit amount or list of allowed tokens for a specific trading bot                                         |\n| [Lit Actions](https://developer.litprotocol.com/sdk/serverless-signing/overview) | The underlying technology that powers both Vincent Tools and Policies, enabling on and off-chain interactions                     | The code that executes token swaps or enforces spending limits using blockchain and API data                               |\n| Vincent Agent Wallet                                                             | A wallet created for each Vincent User that Vincent Apps use to sign transactions on behalf of their App Users                    | A wallet delegated to a Vincent App that dollar-cost-averages into the top cryptocurrency                                  |\n| Vincent App                                                                      | An application that uses Vincent Tools to perform actions on behalf of Vincent App Users governed by Vincent Policies             | A trading bot that uses Vincent Tools to execute trades while respecting user-defined spending limits and token allowlists |\n| Vincent App Version                                                              | Each App Version specifies a specific set of Vincent Tools and Policies that App Users are delegating usage of to the Vincent App | Version 1 of a Vincent trading app includes utilizes a Uniswap Tool with a daily spending limit Policy                     |\n| Vincent App User                                                                 | An individual who delegates actions to Vincent Apps and configures policies to control their behavior                             | A user who allows a trading bot to trade on their behalf with specific spending limits                                     |\n| Vincent App Manager                                                              | The entity responsible for creating and managing a Vincent App, including its versions, tools, and policies                       | A development team that builds and maintains a trading bot, adding new features and policies in each version               |\n\n# Vincent Tool\n\nVincent Tools enable Vincent Apps to perform specific actions on behalf of Vincent App Users. These tools are the core functional units that Vincent Apps use to interact with blockchains, APIs, and other services while being governed by user-configured Vincent Policies.\n\n<!-- TODO Link to Uniswap doc page -->\n\nVincent Tools can read and write data to both on and off-chain sources, perform arbitrary computations, and sign blockchain transactions. This allows them to perform specific actions, such as minting a reward token based on off-chain data, or they can serve general purposes, such as enabling ERC20 token swaps using Uniswap like the Vincent Uniswap Tool.\n\n**On-chain examples:**\n\n- Execute automated DeFi strategies like yield farming or liquidity provision\n- Manage NFT collections by buying, selling, or staking NFTs\n- Perform cross-chain operations like bridging assets or executing cross-chain swaps\n- Interact with DAOs by voting on proposals or executing governance actions\n\n**Off-chain examples:**\n\n- Integrate with traditional finance APIs to manage stock portfolios\n- Connect with social media platforms to automate content posting and engagement\n- Use weather APIs to trigger automated actions based on environmental conditions\n- Interact with e-commerce platforms to manage inventory and process orders\n\nUnder the hood, Vincent Tools are created using [Lit Actions](https://developer.litprotocol.com/sdk/serverless-signing/overview). With the ability to natively interact with any on or off-chain data source (blockchains, social networks, TradFi, etc), Lit Actions are uniquely positioned to support the creation of tools for virtually any use case.\n\n# Vincent Policy\n\nVincent Policies give users full control over defining how their assets and data are used when they interact with a given Vincent App. Each Vincent Policy is assigned to specific Vincent Tool(s) and governs their usage. For example, when interacting with a Vincent App that involves crypto trading, a Policy would be used to specify things like spend limits or token allowlists / denylists. Policies can be thought of as user-defined \"guardrails\" that ensure each Vincent App operates within a given Vincent App User's defined boundaries.\n\nJust like Tools, Vincent Policies are also powered by Lit Actions under the hood. This makes them highly generalizable and well-suited to track and query on or off-chain state to make decisions based on data such as:\n\n- Usage metrics:\n\n  - Tool execution frequency (e.g. max 10 transactions per day)\n  - Session duration limits (e.g. max 2 hours per session)\n  - Concurrent operation limits (e.g. max 3 pending operations)\n\n- Financial controls:\n\n  - Spending amounts over time periods (e.g. daily spending limit of $1,000)\n  - Token-specific limits (e.g. max 5 ERC20 tokens per transaction)\n  - Portfolio allocation limits (e.g. max 20% of portfolio in any single token)\n\n- Access controls:\n\n  - Time-based restrictions (e.g. only during market hours)\n  - Geographic limitations (e.g. restricted to specific regions)\n  - Multi-factor authentication requirements (e.g. require 2FA for high-value transactions)\n\n- Compliance and risk management:\n  - Unusual transaction detection (e.g. flag transactions 3x larger than average)\n  - Rate of change monitoring (e.g. alert on 50% portfolio value change in 24h)\n  - KYC/AML verification requirements (e.g. require verified identity for transactions over $10,000)\n\n## Policy Parameters\n\nVincent Policies utilize parameters defined by the Vincent App User that are stored on-chain, verifiable by anyone. These parameters are specific to each Vincent Tool that a Vincent App executes on behalf of the Vincent App User. Prior to the execution of a Vincent Tool, the Policy parameters are fetched from on-chain and used during the evaluation of the Vincent Policy that governs Vincent tool usage. Only Vincent App Users have the ability to configure these parameters and they can be updated at any time.\n\nAn example Policy is a daily spend limit, assigned to a Vincent App that performs token transfers on behalf of it's App Users. Without the policy, the Vincent App would be able to spend tokens from it's delegated Vincent Users (using a Vincent Tool) without restriction. After enabling the Vincent spending limit policy, the Vincent App's usage of the token transfer Vincent Tool is now governed by the configured daily spending limit set by each of it's Vincent Users. Once the daily spending limit is reached for a specific Vincent User, the Vincent App would no longer be permitted to execute the token transfer Vincent Tool until the spending limit is reset the next day. This ensures that the Vincent App User's assets are protected and their spending is controlled.\n\n# Vincent Agent Wallet\n\nEach Agent Wallet is a non-custodial account powered via [Secure Multi-Party Computation (MPC)](https://en.wikipedia.org/wiki/Secure_multi-party_computation) that enables seamless interactions with any Vincent App. Each Agent Wallet is represented by a [Lit Programmable Key Pair (PKP)](https://developer.litprotocol.com/user-wallets/pkps/overview) and controlled by the Vincent User's desired authentication method. Currently, Vincent supports the following authentication methods during account creation:\n\n- Email\n- SMS\n- Passkey\n\nWhen you interact with a given Vincent App, it will prompt you to delegate signing capabilities from your Agent Wallet to specific Vincent Tools. By delegating these signing capabilities, you enable the Vincent App to execute specific operations on your behalf without requiring your manual intervention. For example, a Vincent trading App would first prompt the user to permit it's custom Vincent swap Tool to have signing capability using their Agent Wallet. The Vincent User would then be prompted to define their desired Policy parameters, such as a spend limit. Once the Vincent User permits the Tool, and any desired Policies were set, the Vincent App would have permission to sign transactions on behalf of the Vincent User according to the guardrails the User has set\n\nBecause Vincent Agent Wallets are PKPs, Vincent Apps can never directly access Agent Wallets directly. Instead, they can only execute the Vincent Tools that the Vincent User has explicitly authorized for each Vincent App. Each Vincent Tool's code strictly defines what data can be signed, and Vincent Apps cannot modify this code or sign any data beyond the Vincent Tool's programmed scope. When a Vincent Tool needs to sign data, like a blockchain transaction, it must request the signature through the Lit network, which verifies the origin of the request came from the authorized Vincent Tool before generating the signature. Any pre-defined Vincent Policies are evaluated prior to Tool execution.\n\n# Vincent App\n\nA Vincent App is a collection of Vincent Tools and their associated Vincent Policies. Vincent Tools define the specific operations that the Vincent App can perform, while Vincent Policies ensure these operations are scoped according to user-defined parameters and permissions.\n\n## App Version\n\nVincent App Versions define the specific set of Vincent Tools and Policies that Vincent Apps can execute on behalf of a Vincent App User. When a Vincent App User wants to delegate signing capabilities to a Vincent App, they must authorize a specific Vincent App Version.\n\nVincent App Managers can create new versions for their Vincent Apps, specifying new Vincent Tools and Policies that will be available to be executed by a Vincent App. Once created, Vincent App Versions are immutable and cannot be altered. Vincent Apps are only authorized to execute the Vincent Tools and Policies associated with the Vincent App Version that's been approved by the Vincent App User.\n\nThis immutability ensures that Apps can evolve and add new features through new versions, but Vincent App Users maintain complete control over what actions can be performed on behalf of their Vincent Agent Wallet. To execute new Vincent Tools and Policies, Vincent App Users must explicitly authorize a new Vincent App Version, guaranteeing that nothing can be executed without their permission.\n\n## App Manager\n\nA Vincent App Manager is a blockchain account (whether a standard externally owned account, or anything else that can sign Ethereum transactions) that creates and manages a Vincent App.\n\nVincent App Managers configure their App's metadata, including it's name, description, redirect URIs, and deployment status. They also define which Vincent Tools and Policies each Vincent App Version will use, and control which Vincent App Versions remain active and available for Vincent App Users to authorize.\n\n## App User\n\nA Vincent App User owns a Vincent Agent Wallet and controls what actions can be performed with it. When a Vincent App User wants to use a Vincent App, they must first authorize a specific Vincent App Version, which defines the set of Vincent Tools and Policies that Vincent Apps can execute on their behalf.\n\nVincent App Users maintain complete control over their assets through two key mechanisms: they explicitly authorize which Vincent App Versions can be used with their Vincent Agent Wallet, and they configure Vincent Policy parameters that restrict how Vincent Tools can be executed.\n\nFor example, a Vincent App User might authorize a trading App's Version that includes a Vincent Tool that swaps tokens on a DEX, but they set a daily spending limit of 1 ETH. The Vincent App can execute the Vincent swap Tool, but only within the constraints of the Vincent App User's configured Policy parameters.\n\nThis authorization model ensures that Vincent App Users can safely delegate actions to Vincent Apps while maintaining control over their assets and the conditions under which those assets can be used.\n\n# How these Concepts Tie Together\n\nThe lifecycle of a Vincent App follows these steps:\n\n1. An App Manager creates a new App, specifying the App metadata, and the Tools and Policies that the first version of the App will use\n2. A User navigates to the App's webapp and clicks a button that uses the Vincent SDK to redirect to the Vincent Consent page\n3. The User authenticates with Vincent and either retrieves an existing Vincent Agent wallet or creates a new one\n4. The User views the Vincent App's Consent page, which displays the App metadata, the Tools and associated Policies that the App Version will use, and provides input fields for any Policy parameters configured for each Tool's Policy\n5. The User approves delegation for the App Version and is redirected back to the App's webapp\n6. The App's webapp receives the redirect from the Vincent Consent page and logs the User in\n7. The User interacts with the webapp and clicks a button that requires execution of a Vincent Tool\n8. The App's webapp backend triggers the Tool execution\n9. The App collects the necessary data for the Tool execution and submits a request to the Lit Protocol network\n10. The Tool begins execution and first checks which Vincent App the executor is associated with\n    - If the executor is not associated with any App, execution halts and returns a not-authorized error\n11. The Tool then checks which App Version the App User has authorized and retrieves the Policies and Policy parameters that the User set for the executing Tool\n12. The Tool then executes each Policy, providing it with the retrieved on-chain Policy parameters\n    - If any Policy returns a "
				},
				{
					"kind": "code",
					"text": "`false`"
				},
				{
					"kind": "text",
					"text": " value or an error, Tool execution halts and returns an error\n13. After all Policies execute successfully, the Tool runs its logic and performs its designed actions\n14. The Tool returns the execution results to the App's webapp backend"
				}
			],
			"frontmatter": {
				"category": "Users"
			}
		},
		{
			"id": 3,
			"name": "Getting Started",
			"variant": "document",
			"kind": 8388608,
			"flags": {},
			"content": [
				{
					"kind": "text",
					"text": "# Getting Started as a Vincent Developer\n\nThere are different types of developers in the Vincent ecosystem depending on what you're building.\n\n## App & Agent Developers\n\nYou’re an App & Agent Developer if you're building an app or autonomous agent that uses Vincent Tools & Policies to perform actions on behalf of Vincent Users.\n\n[Get started with App & Agent Development]("
				},
				{
					"kind": "relative-link",
					"text": "./App-Agent-Developers/Getting-Started.md",
					"target": 3
				},
				{
					"kind": "text",
					"text": ") and learn how to:\n\n- Create and configure a Vincent App\n- Install and use the Vincent App SDK to execute Vincent Tools governed by user-defined Vincent Policies<!-- TODO Link to SDK -->\n\n## Tool Developers\n\nTool Developers create custom tools that enable Vincent Apps to perform specific actions on behalf of users.\n\n[Get started with Tool Development]("
				},
				{
					"kind": "relative-link",
					"text": "./Tool-Developers/Getting-Started.md",
					"target": 4
				},
				{
					"kind": "text",
					"text": ") and learn how to:\n\n- Install and use the [Vincent Tool SDK](https://www.npmjs.com/package/@lit-protocol/vincent-tool-sdk) to define your custom tool logic\n- Declare the Vincent Policies your tool supports\n- Publish and register your tool for Vincent App developers to use\n\n## Policy Developers\n\nPolicy Developers define rules that govern how and when Vincent Tools can be executed by Vincent Apps to execute actions on behalf of Vincent Users.\n\n[Get started with Policy Development]("
				},
				{
					"kind": "relative-link",
					"text": "./Policy-Developers/Getting-Started.md",
					"target": 5
				},
				{
					"kind": "text",
					"text": ") and learn how to:\n\n- Install and use the [Vincent Tool SDK](https://www.npmjs.com/package/@lit-protocol/vincent-tool-sdk) to define your custom policy logic\n- Enable fine-grained, user-defined control over tool execution\n- Publish and register your policy for Vincent App developers to use"
				}
			],
			"frontmatter": {
				"category": "Developers"
			}
		},
		{
			"id": 4,
			"name": "App & Agent Developers",
			"variant": "document",
			"kind": 8388608,
			"flags": {},
			"content": [
				{
					"kind": "text",
					"text": "# What is a Vincent App?\n\nVincent Apps enable secure, policy governed automation on behalf of Vincent Users without compromising custody or control. Whether you're building autonomous agents or integrating with existing web2/web3 apps, Vincent Apps allow users to delegate specific on and off-chain actions to your app through Vincent Tools, each governed by user-configured Vincent Policies. Every action is explicitly authorized, auditable, and executed strictly within the boundaries users configure for your app — all while they retain full control of their assets and private keys.\n\n## Real-World App Examples\n\n**Trading & Investment**\n\n- **DCA Bots**: Execute recurring token purchases across chains, governed by user-defined spend limits and frequency policies\n- **Portfolio Rebalancers**: Rebalance token allocations periodically or on threshold triggers, constrained by slippage, token allowlists, and spend limits\n- **Arbitrage Agents**: Monitor multiple DEXs and CEXs for price discrepancies and execute trades only when profit margins meet user-set minimums\n\n**DeFi Operations**\n\n- **Yield Optimizers**: Move funds between protocols based on live yield data, respecting risk limits, cooldown windows, and slippage boundaries\n- **Liquidity Managers**: Adjust LP exposure based on volume, fees, or impermanent loss forecasts\n- **Collateral Managers**: Automatically maintain healthy loan positions by topping up or unwinding collateral, avoiding liquidation\n- **Subscription Managers**: Automate crypto-based payments for memberships or services, with user-defined billing windows, spend caps, and merchant allowlists\n\n**Cross-Chain Operations**\n\n- **Bridge Monitors**: Automate token transfers across blockchain networks when costs are low or destination liquidity is high\n- **Cross-Chain Arbitrage**: Identify and execute arbitrage opportunities across different networks\n- **Cross-Chain Portfolio Managers**: Maintain portfolio balances across blockchains with Vincent Policy governed routing and transfer limits\n\n**Data-Driven Automation**\n\n- **Market Data Agents**: Parse both on and off-chain data feeds, oracles, and TA indicators to execute trades only when strategies align with user-set conditions\n- **Social Sentiment Bots**: Monitor social and news sentiment and trigger Vincent Tools in response to trend shifts\n\n# Next Steps\n\n- Check out the [Creating a Vincent App]("
				},
				{
					"kind": "relative-link",
					"text": "./Creating-Apps.md",
					"target": 7
				},
				{
					"kind": "text",
					"text": ") guide to get started\n- Learn how to [Authenticate Vincent Users]("
				},
				{
					"kind": "relative-link",
					"text": "./Auth-Users.md",
					"target": 8
				},
				{
					"kind": "text",
					"text": ") in your frontend app\n- See how to [execute Vincent Tools]("
				},
				{
					"kind": "relative-link",
					"text": "./Executing-Tools.md",
					"target": 9
				},
				{
					"kind": "text",
					"text": ") on behalf of your App Users\n- Checkout the official [Automated Dollar-cost-averaging](https://demo.heyvincent.ai/) Vincent demo and explore it's [source code](https://github.com/LIT-Protocol/vincent-dca)\n- Join the [Vincent community](https://t.me/c/2038294753/3289) for support and collaboration"
				}
			],
			"frontmatter": {
				"category": "Developers"
			}
		},
		{
			"id": 5,
			"name": "Tool Developers",
			"variant": "document",
			"kind": 8388608,
			"flags": {},
			"content": [
				{
					"kind": "text",
					"text": "# What is a Vincent Tool?\n\nA Vincent Tool is a function built using [Lit Actions](https://developer.litprotocol.com/sdk/serverless-signing/overview) that enables Vincent Apps to perform specific actions on behalf of Vincent App Users. These tools are the core functional units that Vincent Apps use to interact with blockchains, APIs, and other services while being governed by user-configured [Vincent Policies]("
				},
				{
					"kind": "relative-link",
					"text": "../Policy-Developers/Getting-Started.md",
					"target": 5
				},
				{
					"kind": "text",
					"text": ").\n\n## Key Capabilities of Vincent Tools\n\nVincent Tools provide powerful capabilities that enable a wide variety of blockchain and web2 actions:\n\n- **Flexible Data Access:** Read and write both on and off-chain data to any blockchain network or HTTP-accessible API or database\n- **Policy-Driven Execution:** Execute tools only when permitted by all registered Vincent Policies for the Vincent App User\n- **Cryptographic Capabilities:** Sign transactions and data on behalf of users, and utilize Lit Protocol's [Encryption and Access Control](https://developer.litprotocol.com/sdk/access-control/intro) features for conditional data access\n- **Type-Safe Development:** Strongly-typed Zod schemas ensure parameter validation and clear interfaces between Vincent Tools and Policies, and both utilize packages installed from NPM to extend functionality\n\n## Real-World Tool Examples\n\n**Blockchain Interactions**\n\n- **Token Transfers**: Transfer tokens across different blockchain networks in a single tool execution\n- **NFT Operations**: Mint, transfer, and manage NFTs with customizable metadata and royalty settings\n- **DeFi Actions**: Interact with DeFi protocols to perform swaps, liquidity provision, or yield farming\n\n**Data Management**\n\n- **Cross-Chain Data**: Aggregate and process data from multiple blockchain networks\n- **API Integration**: Fetch and process data from external APIs while keeping the data private\n- **Database Operations**: Perform read/write operations to databases with Vincent Policy based access control\n\n**Authentication & Security**\n\n- **Multi-Signature Operations**: Coordinate multi-sig transactions across different wallets and blockchains\n- **Encrypted Data Access**: Handle encrypted data storage and retrieval with Vincent Policy based access control\n- **Identity Verification**: Verify user identity through various on-chain and off-chain methods\n\n**Automation & Scheduling**\n\n- **Scheduled Transactions**: Execute transactions at specific times or based on certain conditions\n- **Automated Trading**: Execute trading strategies with built-in risk management\n- **Event-Triggered Actions**: Respond to on-chain or off-chain events"
				}
			],
			"frontmatter": {
				"category": "Developers"
			}
		},
		{
			"id": 6,
			"name": "Policy Developers",
			"variant": "document",
			"kind": 8388608,
			"flags": {},
			"content": [
				{
					"kind": "text",
					"text": "# What is a Vincent Policy?\n\nA Vincent Policy is a function built using [Lit Actions](https://developer.litprotocol.com/sdk/serverless-signing/overview) and is a programmable guardrail for [Vincent Tool]("
				},
				{
					"kind": "relative-link",
					"text": "../Tool-Developers/Getting-Started.md",
					"target": 4
				},
				{
					"kind": "text",
					"text": ") executions. These policies have user-configurable parameters and determine whether a Vincent App can execute specific Vincent Tools on behalf of a Vincent App User, ensuring that autonomous agents and Vincent Apps operate strictly within user-defined boundaries.\n\n## Key Capabilities of Vincent Policies\n\n- **Flexible Data Access:** Read and write both on and off-chain data to any blockchain network or HTTP-accessible API or database\n- **Stateful Policy Management:** Persist data across executions to track cumulative metrics and implement sophisticated rules like spending limits, rate limiting, and usage quotas\n- **Cryptographic Capabilities:** Utilize Lit Protocol's [Encryption and Access Control ](https://developer.litprotocol.com/sdk/access-control/intro) features for computing over private data within Lit's secure [Trusted Execution Environment (TEE)](https://en.wikipedia.org/wiki/Trusted_execution_environment)\n- **Type-Safe Development:** Strongly-typed Zod schemas ensure parameter validation and clear interfaces between Vincent Tools and Policies, and both utilize packages installed from NPM to extend functionality\n\n## Real-World Policy Examples\n\n**Financial Controls**\n\n- **Daily Spending Limits**: Track cumulative spending by storing transaction amounts on or off-chain and deny Vincent Tool execution when limits are exceeded\n- **Multi-Signature Requirements**: Require additional approvals for high-value transactions by integrating with on or off-chain approval systems\n- **Token Allowlists**: Restrict transactions to specific token types or verified contract addresses\n\n**Access Management**\n\n- **Membership Gates**: Verify ownership of on-chain assets (like NFTs), or off-chain data (like Discord roles) before allowing access to premium features\n- **Time-Based Restrictions**: Only allow Vincent Tool execution during specific hours, days, or based on cooldown periods\n\n**Usage Limits**\n\n- **Rate Limiting**: Track API usage frequency and implement cooldown periods between executions\n- **Compliance Monitoring**: Enforce regulatory requirements by checking transaction amounts against legal limits\n- **Geographic Restrictions**: Use IP geolocation APIs to restrict access based on user location\n\n**Risk Management**\n\n- **Transaction Pattern Analysis**: Monitor spending patterns and flag suspicious activity that deviates from normal behavior\n- **Circuit Breakers**: Automatically disable tools when unusual activity is detected or system-wide limits are reached\n- **Emergency Stops**: Implement admin-controlled emergency stops that can pause policy-governed operations"
				}
			],
			"frontmatter": {
				"category": "Developers"
			}
		},
		{
			"id": 7,
			"name": "Creating Vincent Apps",
			"variant": "document",
			"kind": 8388608,
			"flags": {},
			"content": [
				{
					"kind": "text",
					"text": "# How a Vincent App Works\n\n<div class=\"info-box\">\n  <p class=\"info-box-title\">\n    <span class=\"info-icon\">Info</span> Note\n  </p>\n  <p>In this guide, you'll create and register your first Vincent App using the <a href=\"https://dashboard.heyvincent.ai/\">Vincent App Dashboard</a>. You’ll select from existing Vincent Tools and Policies, configure your App metadata, and register the App Delegatees whom are authorized to execute your App's Tools.</p>\n  <p>If you're unfamiliar with what a Vincent App is, checkout the <a href=\""
				},
				{
					"kind": "relative-link",
					"text": "./Getting-Started.md",
					"target": 3
				},
				{
					"kind": "text",
					"text": "\">Getting Started</a> guide to learn more.</p>\n</div>\n\nA Vincent App is composed of four key elements:\n\n1. **Vincent Tools**: Modular, executable functions that define the operations your App can perform on behalf of its Users.\n\n- Tools can interact with blockchains, APIs, databases, or any service reachable via JavaScript and HTTP requests.\n- Each Tool is immutable once published and can only be executed under the conditions explicitly approved by the User ensuring transparent, tamper-proof behavior.\n\n2. **Vincent Policies**: Programmable guardrails that govern when and how Vincent Tools can be executed.\n\n- Policies are immutable once published, and are configurable per User ensuring that every Tool execution is tightly scoped to each User’s explicit intent.\n\n3. **Vincent App Delegatees**: Ethereum addresses authorized by your App to execute Tools on behalf of Vincent Users.\n\n4. **Vincent Agent Wallets**: Non-custodial wallets that enable secure, automated interactions between your Vincent App and its Users.\n\n- Each Agent Wallet is powered by Lit Protocol's [Programmable Key Pairs (PKPs)](https://developer.litprotocol.com/user-wallets/pkps/overview), allowing Users to retain full control over their keys and assets while delegating narrowly scoped signing permissions specific to each Vincent Tool.\n\n# Defining Your Vincent App\n\nBefore registering your Vincent App, you’ll need to decide on the core components that make up its behavior and the Policies your App Users will use to govern its execution.\n\n# 1. Selecting Vincent Tools\n\nVincent Tools define the executable operations your App can perform on behalf of its Users such as swapping tokens, transferring assets, or querying APIs.\n\n<div class=\"info-box\">\n  <p class=\"info-box-title\">\n    <span class=\"info-icon\">Info</span> Note\n  </p>\n  <p>A Vincent Tool Registry that contains a list of all the available Vincent Tools and their associated Policies will be available soon.</p>\n\n  <p>For now you'll need to manually copy and paste the IPFS CID of each Vincent Tool you'd like to use in your App into the Vincent App Dashboard when registering your App.</p>\n  <p>The below table includes links to the IPFS CID of each Tool that will be automatically updated as new iterations of the Tool are published.</p>\n\n  <p>Join the <a href=\"https://t.me/+aa73FAF9Vp82ZjJh\">Vincent Community</a> to stay up to date.</p>\n</div>\n\nThe following Vincent Tools have been published by the Vincent team and are available to use in your Vincent App:\n\n| Tool                                                                                                        | Description                                                                                                                                          | IPFS CID                                                                                                                             |\n| ----------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------ |\n| [ERC20 Token Approval](https://github.com/LIT-Protocol/Vincent/tree/main/packages/apps/tool-erc20-approval) | Allows Vincent Apps to get token approvals from Vincent Users to execute ERC20 token transfers                                                       | [Link](https://github.com/LIT-Protocol/Vincent/blob/main/packages/apps/tool-erc20-approval/src/generated/vincent-tool-metadata.json) |\n| [Uniswap Swap Tool](https://github.com/LIT-Protocol/Vincent/tree/main/packages/apps/tool-uniswap-swap)      | Allows Vincent Apps to perform swaps using Uniswap on any [chain supported by the Uniswap SDK](https://api-docs.uniswap.org/guides/supported_chains) | [Link](https://github.com/LIT-Protocol/Vincent/blob/main/packages/apps/tool-uniswap-swap/src/generated/vincent-tool-metadata.json)   |\n\nAdditionally, you can checkout the [Creating a Vincent Tool]("
				},
				{
					"kind": "relative-link",
					"text": "../Tool-Developers/Creating-Tools.md",
					"target": 10
				},
				{
					"kind": "text",
					"text": ") guide to learn how to create your own Vincent Tools to perform any on or off-chain action your Vincent App needs.\n\n# 2. Selecting Vincent Policies\n\nVincent Policies are programmable constraints that govern when and how each Vincent Tool can be executed.\n\n<div class=\"info-box\">\n  <p class=\"info-box-title\">\n    <span class=\"info-icon\">Info</span> Note\n  </p>\n  <p>Similar to selecting which Vincent Tools you'd like your App to use, you'll need to manually copy and paste the IPFS CID of each Vincent Policy you'd like to use for each Tool into the Vincent App Dashboard when registering your App.</p>\n  <p>The below table includes links to the IPFS CID of each Policy that will be automatically updated as new iterations of the Policy are published.</p>\n</div>\n\nThe following Vincent Policies have been published by the Vincent team and are available to use in your Vincent App:\n\n| Tool                                                                                                          | Description                                                                                       | IPFS CID                                                                                                                                 |\n| ------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |\n| [Daily Spending Limit](https://github.com/LIT-Protocol/Vincent/tree/main/packages/apps/policy-spending-limit) | Allows Vincent Users to restrict the amount of USD spent per day on their behalf by a Vincent App | [Link](https://github.com/LIT-Protocol/Vincent/blob/main/packages/apps/policy-spending-limit/src/generated/vincent-policy-metadata.json) |\n\nAdditionally, you can checkout the [Creating a Vincent Policy]("
				},
				{
					"kind": "relative-link",
					"text": "../Policy-Developers/Creating-Policies.md",
					"target": 11
				},
				{
					"kind": "text",
					"text": ") guide to learn how to create your own Vincent Policies to govern the execution of Vincent Tools.\n\n# 3. Registering Your Vincent App\n\n<div class=\"info-box\">\n  <p class=\"info-box-title\">\n    <span class=\"info-icon\">Info</span> Before registering your Vincent App\n  </p>\n  <p>Registering an App requires that you have tokens on Lit Protocol's Yellowstone blockchain to pay for gas. You can use <a href=\"https://chronicle-yellowstone-faucet.getlit.dev/\">this faucet</a> to get the Lit test tokens used to pay for registering your App.</p>\n</div>\n\nOnce you've selected your Vincent Tools and Policies, you'll need to register your App using the [Vincent App Dashboard](https://dashboard.heyvincent.ai/).\n\n## Connecting your App Management Wallet to the App Dashboard\n\nBefore you can register your App, you'll need to connect an Ethereum wallet to the App Dashboard.\n\nThis wallet will be the Vincent App Manager for your new App and is responsible for creating new App Versions, defining which Vincent Tools and Policies are used in each App Version, as well as the managing the App Delegatees that are permitted to execute Tools on behalf of your App's Vincent Users.\n\n![Connect App Management Wallet]("
				},
				{
					"kind": "relative-link",
					"text": "../images/connect-app-management-wallet.png",
					"target": 12
				},
				{
					"kind": "text",
					"text": ")\n\n## Creating your App\n\nAfter connecting your Vincent App Manager wallet to the App Dashboard, you can create a new App by clicking on the "
				},
				{
					"kind": "code",
					"text": "`Create New App`"
				},
				{
					"kind": "text",
					"text": " button which will take you to the following screen:\n\n![Create New App]("
				},
				{
					"kind": "relative-link",
					"text": "../images/create-new-app.png",
					"target": 13
				},
				{
					"kind": "text",
					"text": ")\n\nOn this screen you'll need to define the following:\n\n### Application Name & Description\n\nThis is the name of your App that will be used to identify your App within the Vincent ecosystem, and the description used to detail what your App is offering to do on behalf of its Users.\n\nIt's also displayed to the Vincent User when they are interacting with the Vincent Consent page to permit delegation to your App and configure their Policy parameters.\n\nIn this example image, "
				},
				{
					"kind": "code",
					"text": "`Automated Memecoin Dollar-Cost-Averaging`"
				},
				{
					"kind": "text",
					"text": " is the name of the Vincent App, and "
				},
				{
					"kind": "code",
					"text": "`This demo agent automatically identifies and purchases the top-performing Base memecoin on your predefined schedule.`"
				},
				{
					"kind": "text",
					"text": " is the description of the App:\n\n![Consent UI]("
				},
				{
					"kind": "relative-link",
					"text": "../images/consent-ui.png",
					"target": 14
				},
				{
					"kind": "text",
					"text": ")\n\n### App Mode\n\nDefines the current deployment status of your App.\n\nThis setting will be used to filter the Apps displayed in the Vincent App Registry, so that "
				},
				{
					"kind": "code",
					"text": "`DEV`"
				},
				{
					"kind": "text",
					"text": " and "
				},
				{
					"kind": "code",
					"text": "`TEST`"
				},
				{
					"kind": "text",
					"text": " Apps are not displayed to Vincent Users when looking at the Registry. Use:\n\n- "
				},
				{
					"kind": "code",
					"text": "`DEV`"
				},
				{
					"kind": "text",
					"text": " If you're currently developing the Vincent App and it's not ready to be used by your Vincent Users\n- "
				},
				{
					"kind": "code",
					"text": "`TEST`"
				},
				{
					"kind": "text",
					"text": " If you're currently testing the Vincent App with your Vincent Users, and want to make the distinction that your App is not yet ready for production\n- "
				},
				{
					"kind": "code",
					"text": "`PROD`"
				},
				{
					"kind": "text",
					"text": " If you've finished development and your App is ready to be used by your Vincent Users\n\n### Authorized Redirect URIs\n\nThis is a list of URLs that are authorized to receive the Json Web Token (JWT) from the Vincent Consent page.\n\nAfter Vincent Users have permitted delegation to your App, or are logging back into your App using Vincent, these redirect URIs are the only valid locations they can be redirected to from the Vincent Consent page back to your App.\n\nIncluded in the URL parameters of the redirect URI is a Json Web Token (JWT) that is given to your App to identify the Vincent User and the App Version they've authorized. This allows you to know which Vincent Tools and Policies the User has permitted your App to execute on their behalf.\n\n### Tools\n\nThis section is where you'll define the IPFS CIDs of each Vincent Tool that will be used in your App. You can copy and paste the IPFS CID of each Tool you'd like your App to use into this section.\n\nFor the available Tools, see the [Selecting Vincent Tools](#1-selecting-vincent-tools) section which contains links to the IPFS CIDs for each Tool, or use the IPFS CID of any custom Tool you've developed.\n\n> **Note:** The [Creating a Vincent Tool]("
				},
				{
					"kind": "relative-link",
					"text": "../Tool-Developers/Creating-Tools.md",
					"target": 10
				},
				{
					"kind": "text",
					"text": ") guide contains instructions for how to create your own Vincent Tools to perform any on or off-chain action your Vincent App needs.\n\n#### Policies\n\nEach Vincent Tool has a list of supported Vincent Policies that can govern the execution of the Tool. It's up to you to select which Policies your Users can configure for each Tool your App uses.\n\nYou can add Policies for each Tool by clicking the "
				},
				{
					"kind": "code",
					"text": "`Add Policy`"
				},
				{
					"kind": "text",
					"text": " button and copy and pasting the IPFS CID of each Policy.\n\nFor the Tools mentioned in the [Selecting Vincent Tools](#1-selecting-vincent-tools) section, the following Policies are supported:\n\n| Tool                                                                                                        | Supported Policies                                                                                            | Policy IPFS CID                                                                                                                          |\n| ----------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |\n| [ERC20 Token Approval](https://github.com/LIT-Protocol/Vincent/tree/main/packages/apps/tool-erc20-approval) | None                                                                                                          | -                                                                                                                                        |\n| [Uniswap Swap Tool](https://github.com/LIT-Protocol/Vincent/tree/main/packages/apps/tool-uniswap-swap)      | [Daily Spending Limit](https://github.com/LIT-Protocol/Vincent/tree/main/packages/apps/policy-spending-limit) | [Link](https://github.com/LIT-Protocol/Vincent/blob/main/packages/apps/policy-spending-limit/src/generated/vincent-policy-metadata.json) |\n\n#### Policy Parameters\n\nEach Policy has parameters that can be configured by the Vincent User to explicitly define the conditions under which the Tool can be executed.\n\nThis section is where you'll define the parameters Users can configure for each Tool Policy.\n\nEach Policy has a parameter name and type, where the name and type of each parameter must match what the Policy is expecting.\n\nFor the Policies mentioned in the [Selecting Vincent Policies](#2-selecting-vincent-policies) section, the following parameters are supported:\n\n| Policy                                                                                                        | Parameter Name                    | Parameter Type |\n| ------------------------------------------------------------------------------------------------------------- | --------------------------------- | -------------- |\n| [Daily Spending Limit](https://github.com/LIT-Protocol/Vincent/tree/main/packages/apps/policy-spending-limit) | "
				},
				{
					"kind": "code",
					"text": "`maxDailySpendingLimitInUsdCents`"
				},
				{
					"kind": "text",
					"text": " | "
				},
				{
					"kind": "code",
					"text": "`uint256`"
				},
				{
					"kind": "text",
					"text": "      |\n\nAfter defining the above details for your App, you can click on the "
				},
				{
					"kind": "code",
					"text": "`Submit Application`"
				},
				{
					"kind": "text",
					"text": " button to create your App. This will prompt you to sign a transaction using your App Management Wallet to register your App on-chain using the Lit Protocol [Chronicle Yellowstone blockchain](https://developer.litprotocol.com/connecting-to-a-lit-network/lit-blockchains/chronicle-yellowstone).\n\n## Adding Delegatees to your App\n\nIn order to execute your App's Vincent Tools, you'll need to register App Delegatees. These delegatees are defined as Ethereum addresses that are authorized by your App to execute the Tools that Vincent Users have permitted for your App.\n\nAfter creating your App, you'll be redirected to the dashboard overview screen. Click the box with the name of the App you just created, and you'll be taken to the App's settings screen.\n\nNext click the "
				},
				{
					"kind": "code",
					"text": "`Manage Delegatees`"
				},
				{
					"kind": "text",
					"text": " button to add the App Delegatees you'd like to authorize to execute your App's Vincent Tools:\n\n![Manage Delegatees]("
				},
				{
					"kind": "relative-link",
					"text": "../images/vincent-app-manage-delegatees.png",
					"target": 15
				},
				{
					"kind": "text",
					"text": ")\n\nYou will now be given two buttons:\n\n- "
				},
				{
					"kind": "code",
					"text": "`Generate Delegatee`"
				},
				{
					"kind": "text",
					"text": " - This will generate a new Ethereum wallet giving you the private key and Ethereum address of the new wallet\n  - Use this option if you don't have an existing wallet you'd like to use as an App Delegatee\n- "
				},
				{
					"kind": "code",
					"text": "`Add Delegatee`"
				},
				{
					"kind": "text",
					"text": " - This will prompt you to provide the Ethereum address of an existing wallet you'd like to authorize as an App Delegatee\n\nWhether you choose to generate a new wallet or add an existing wallet, you'll be prompted to sign a transaction using your App Management Wallet to register the App Delegatee on-chain using the Lit Protocol [Chronicle Yellowstone blockchain](https://developer.litprotocol.com/connecting-to-a-lit-network/lit-blockchains/chronicle-yellowstone).\n\n## Generating Your App Link\n\nAt this point you have registered and configured your Vincent App, and it's ready to start having Vincent Users delegate to it.\n\nIn order to do this, User needs to have a link to the Vincent Consent page that has your App's metadata. This link can be generated for you by clicking the "
				},
				{
					"kind": "code",
					"text": "`Generate App URL`"
				},
				{
					"kind": "text",
					"text": " button on the App's settings screen:\n\n![Generate App URL]("
				},
				{
					"kind": "relative-link",
					"text": "../images/vincent-app-generate-app-url.png",
					"target": 16
				},
				{
					"kind": "text",
					"text": ")\n\nYou will be prompted to select which Authorized Redirect URI (you configured in the [Creating your App](#creating-your-app) section) you'd like Users to be redirected to after they've permitted delegation to your App, or are logging back into your App using Vincent.\n\nAfter selecting the Authorized Redirect URI, click on the "
				},
				{
					"kind": "code",
					"text": "`Copy Application URL`"
				},
				{
					"kind": "text",
					"text": " button to copy the link to the Vincent Consent page for your App to your clipboard. The link will look similar to:\n\n"
				},
				{
					"kind": "code",
					"text": "```\nhttps://dashboard.heyvincent.ai/appId/526/consent?redirectUri=https%3A%2F%2Fyour-redirect-uri.com\n```"
				},
				{
					"kind": "text",
					"text": "\n\nYou can now share this link to allow Users to delegate the ability to execute your App's Vincent Tools on their behalf.\n\n# Wrapping Up\n\nYou’ve now learned how to create and register a Vincent App using the [Vincent App Dashboard](https://dashboard.heyvincent.ai/).\n\nFrom selecting Tools and Policies to configuring App metadata and adding Delegatees, you’ve completed the full setup process to launch your Vincent App and start executing Vincent Tools on behalf of your Vincent Users.\n\nHere’s a quick recap of what you covered:\n\n- **Understanding the Core Concepts:** A Vincent App is composed of the following components that work together to enable trusted automation without sacrificing User control:\n  - Vincent Tools (what your App can do)\n  - Vincent Policies (User defined guardrails)\n  - App Delegatees (Ethereum addresses authorized to execute Tools)\n- **Selecting Vincent Tools:** Choose from existing Tools like ERC20 Approvals or Uniswap Swaps, or build your own Tools to define the actions your App can perform on behalf of it's Users.\n- **Selecting Vincent Policies:** Add programmable constraints to each Tool such as spending limits or token allowlists that ensure each execution respects the User’s intent.\n- **Registering Your App:** Use the Vincent App Dashboard to define your App including details such as it's name, description, authorized redirect URIs, and the selected Tools and Policies.\n- **Adding Delegatees:** Specify the Ethereum addresses that will act on behalf of your Vincent App to execute Tools Users have permitted.\n- **Generating Your App Link:** Generate a Vincent Consent URL that lets Users delegatee access to their Vincent Agent Wallets, so that your App Delegatees can execute Tools on their behalf.\n\n## Next Steps\n\n- If your App requires the ability to perform an action not offered by existing Vincent Tools, checkout how to get started with [Creating a Vincent Tool]("
				},
				{
					"kind": "relative-link",
					"text": "../Tool-Developers/Getting-Started.md",
					"target": 4
				},
				{
					"kind": "text",
					"text": ") to learn how to perform any on or off-chain action your Vincent App needs.\n- If the existing Vincent Policies don't meet your App's needs, checkout how to get started with [Creating a Vincent Policy]("
				},
				{
					"kind": "relative-link",
					"text": "../Policy-Developers/Getting-Started.md",
					"target": 5
				},
				{
					"kind": "text",
					"text": ") to learn how to create your own Vincent Policies to govern the execution of Vincent Tools."
				}
			],
			"frontmatter": {
				"category": "Developers"
			}
		},
		{
			"id": 8,
			"name": "Authenticating Vincent Users",
			"variant": "document",
			"kind": 8388608,
			"flags": {},
			"content": [
				{
					"kind": "text",
					"text": "# Authenticating Users Using the Vincent Web App Client\n\nExported from the Vincent App SDK, the Vincent Web App Client provides methods for securely authenticating users and obtaining their consent to execute Vincent Tools on their behalf.\n\nUsing the Web App Client, you can direct users to the Vincent Consent page where:\n\n- New users can review the Tools your App is requesting permission to execute and configure the Vincent Policies that govern their use.\n- Returning users can log in and confirm both their identity and the specific App Version they’ve previously authorized to act on their behalf.\n\nThis guide walks you through the process of authenticating Vincent Users in your frontend application using the Web App Client.\n\n# Vincent JWT Overview\n\nAt the end of the Vincent Consent flow, the User’s Agent Wallet signs a JWT and returns it as a URL parameter in the redirect URI. This JWT proves that:\n\n- The User has been authenticated using their Agent Wallet\n- The User has granted your Vincent App permission to act on their behalf\n\n## JWT Structure\n\nEach Vincent JWT contains the following claims in its payload:\n\n- "
				},
				{
					"kind": "code",
					"text": "`pkp`"
				},
				{
					"kind": "text",
					"text": ": An object representing the User’s Agent Wallet, including their ethAddress, publicKey, and tokenId\n- "
				},
				{
					"kind": "code",
					"text": "`app`"
				},
				{
					"kind": "text",
					"text": ": The Vincent App the JWT was issued for, including:\n  - "
				},
				{
					"kind": "code",
					"text": "`id`"
				},
				{
					"kind": "text",
					"text": ": The App ID\n  - "
				},
				{
					"kind": "code",
					"text": "`version`"
				},
				{
					"kind": "text",
					"text": ": The specific App Version the User has authorized\n- "
				},
				{
					"kind": "code",
					"text": "`authentication`"
				},
				{
					"kind": "text",
					"text": ": The method used to authenticate the User, such as:\n  - "
				},
				{
					"kind": "code",
					"text": "`type`"
				},
				{
					"kind": "text",
					"text": ": \"email\", \"phone\", or \"passkey\"\n  - "
				},
				{
					"kind": "code",
					"text": "`value`"
				},
				{
					"kind": "text",
					"text": ": (Optional) identifier used during authentication (e.g. email address)\n- "
				},
				{
					"kind": "code",
					"text": "`aud`"
				},
				{
					"kind": "text",
					"text": ": The audience this JWT is valid for (typically your app’s domain or redirect URI)\n- "
				},
				{
					"kind": "code",
					"text": "`exp`"
				},
				{
					"kind": "text",
					"text": ": Expiration timestamp (in seconds since Unix epoch)\n\nIn addition to the payload, the JWT also includes:\n\n- "
				},
				{
					"kind": "code",
					"text": "`header`"
				},
				{
					"kind": "text",
					"text": ": Standard JWT header containing algorithm and type information\n- "
				},
				{
					"kind": "code",
					"text": "`signature`"
				},
				{
					"kind": "text",
					"text": ": A signature from the User’s Agent Wallet proving the JWT was signed using their Agent Wallet\n- "
				},
				{
					"kind": "code",
					"text": "`data`"
				},
				{
					"kind": "text",
					"text": ": The raw, unsigned payload string used during signing\n\n> **Note:** To access these claims, use [decodeVincentLoginJWT](#decodevincentloginjwt) in your frontend.\n\n## Authentication Flow\n\n1. Your App redirects the user to the Vincent Consent Page using "
				},
				{
					"kind": "code",
					"text": "`redirectToConsentPage`"
				},
				{
					"kind": "text",
					"text": "\n2. The User reviews the Tools your App wants to use and configures the Policies that will govern them\n3. Upon approval, the User is redirected back to your App with a signed JWT in the URL\n4. Your App extracts and verifies the JWT using "
				},
				{
					"kind": "code",
					"text": "`decodeVincentLoginJWT`"
				},
				{
					"kind": "text",
					"text": "\n5. The verified JWT can now be stored and used to:\n   - Authenticate requests to your backend APIs\n   - Execute Vincent Tools on behalf of the User\n\n# How the Vincent Web App Client Works\n\nThe "
				},
				{
					"kind": "code",
					"text": "`getVincentWebAppClient`"
				},
				{
					"kind": "text",
					"text": " function from the "
				},
				{
					"kind": "code",
					"text": "`@lit-protocol/vincent-app-sdk`"
				},
				{
					"kind": "text",
					"text": " package creates a Web App Client instance tied to your Vincent App’s ID. This client exposes a set of methods for handling user login, consent, and JWT management for your App's frontend.\n\nThe Web App Client exposes the following methods:\n\n## "
				},
				{
					"kind": "code",
					"text": "`redirectToConsentPage`"
				},
				{
					"kind": "text",
					"text": "\n\nRedirects the user to the Vincent Consent Page, and once the User has completed the Consent flow, they will be redirected back to your App with a signed JWT that you can use to authenticate requests against your backend APIs.\n\n- New Users are shown the Tools your App wants to execute and can configure the Vincent Policies that govern their use.\n- Returning Users can log in and confirm their prior delegation to your App.\n- When a Vincent JWT is expired, use this method to get a new JWT\n\n## "
				},
				{
					"kind": "code",
					"text": "`isLoginUri`"
				},
				{
					"kind": "text",
					"text": "\n\nReturns "
				},
				{
					"kind": "code",
					"text": "`true`"
				},
				{
					"kind": "text",
					"text": " if the current URL contains a Vincent login JWT, indicating the User has just completed the consent flow and should be authenticated.\n\nIf this method returns "
				},
				{
					"kind": "code",
					"text": "`false`"
				},
				{
					"kind": "text",
					"text": ", you should use the "
				},
				{
					"kind": "code",
					"text": "`redirectToConsentPage`"
				},
				{
					"kind": "text",
					"text": " method to to authenticate the User.\n\n## "
				},
				{
					"kind": "code",
					"text": "`decodeVincentLoginJWT`"
				},
				{
					"kind": "text",
					"text": "\n\nExtracts and verifies the Vincent login JWT returned in the URL after a user completes the Consent flow.\n\nThis method performs full validation, including:\n\n- Verifying that the JWT was signed by the Vincent User’s Agent Wallet\n- Ensuring the JWT has not expired\n- Confirming the JWT was issued specifically for your App, by checking that the redirect URI that received the JWT from the Vincent Consent Page is included in the JWT's audience claim\n\nIf the JWT is valid, it returns the decoded JWT object containing identity and delegation details (as described in the [JWT Structure](#jwt-structure) section). If the JWT is invalid, expired, or mis-scoped, an error is thrown.\n\n## "
				},
				{
					"kind": "code",
					"text": "`removeLoginJWTFromURI`"
				},
				{
					"kind": "text",
					"text": "\n\nUse this method to remove the Vincent JWT query parameter from the current URL after you’ve extracted and stored it. You should call this method after you've called "
				},
				{
					"kind": "code",
					"text": "`decodeVincentLoginJWT`"
				},
				{
					"kind": "text",
					"text": ", validated the JWT, and stored it locally to be used when making authenticated requests to your backend APIs.\n\n# Creating a Web App Client\n\nTo initialize the Web App Client, import and call the "
				},
				{
					"kind": "code",
					"text": "`getVincentWebAppClient`"
				},
				{
					"kind": "text",
					"text": " function with your App’s ID:\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { getVincentWebAppClient } from '@lit-protocol/vincent-app-sdk';\n\nconst vincentAppClient = getVincentWebAppClient({ appId: process.env.MY_VINCENT_APP_ID });\n```"
				},
				{
					"kind": "text",
					"text": "\n\nThe "
				},
				{
					"kind": "code",
					"text": "`getVincentWebAppClient`"
				},
				{
					"kind": "text",
					"text": " takes an object as an argument with the following properties:\n\n- "
				},
				{
					"kind": "code",
					"text": "`appId`"
				},
				{
					"kind": "text",
					"text": ": The ID of your Vincent App.\n  - This ID can be found on your [Vincent App Dashboard](https://dashboard.heyvincent.ai/):\n\n![Vincent App Dashboard]("
				},
				{
					"kind": "relative-link",
					"text": "../images/vincent-app-dashboard.png",
					"target": 17
				},
				{
					"kind": "text",
					"text": ")\n\n# Handling Login Flow\n\nUse the following pattern to manage login and redirect flows in your frontend:\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { getVincentWebAppClient, jwt } from '@lit-protocol/vincent-app-sdk';\n\nconst { isExpired } = jwt;\n\nconst vincentAppClient = getVincentWebAppClient({ appId: process.env.MY_VINCENT_APP_ID });\n\nif (vincentAppClient.isLoginUri()) {\n  const { decodedJWT, jwtStr } = vincentAppClient.decodeVincentLoginJWT(window.location.origin);\n\n  // Store JWT for later use\n  localStorage.setItem('VINCENT_AUTH_JWT', jwtStr);\n\n  // Clean up the URL\n  vincentAppClient.removeLoginJWTFromURI();\n\n  // Proceed with App logic for an authenticated User\n} else {\n  const storedJwt = localStorage.getItem('VINCENT_AUTH_JWT');\n  const isExpired = storedJwt ? jwt.isExpired(storedJwt) : true;\n\n  if (!storedJwt || isExpired) {\n    vincentAppClient.redirectToConsentPage({ redirectUri: window.location.href });\n  }\n\n  // Proceed with App logic for an authenticated User\n}\n```"
				},
				{
					"kind": "text",
					"text": "\n\n> **Note:** The "
				},
				{
					"kind": "code",
					"text": "`redirectUri`"
				},
				{
					"kind": "text",
					"text": " given to "
				},
				{
					"kind": "code",
					"text": "`redirectToConsentPage`"
				},
				{
					"kind": "text",
					"text": " is where the user will be sent with the signed Vincent JWT after completing the Vincent Consent flow.\n>\n> This **must** be one of the [Authorized Redirect URIs]("
				},
				{
					"kind": "relative-link",
					"text": "Creating-Apps.md#authorized-redirect-uris",
					"target": 7,
					"targetAnchor": "authorized-redirect-uris"
				},
				{
					"kind": "text",
					"text": ") you've configured for your App.\n\n# Wrapping Up\n\nBy integrating the Vincent Web App Client, your App now supports secure authentication for Vincent Users.\n\nYou’ve learned how to:\n\n- Redirect users to the Vincent Consent Page using "
				},
				{
					"kind": "code",
					"text": "`redirectToConsentPage`"
				},
				{
					"kind": "text",
					"text": "\n- Detect when a User returns from the Consent flow with "
				},
				{
					"kind": "code",
					"text": "`isLoginUri`"
				},
				{
					"kind": "text",
					"text": "\n- Decode and validate the returned JWT using "
				},
				{
					"kind": "code",
					"text": "`decodeVincentLoginJWT`"
				},
				{
					"kind": "text",
					"text": "\n- Store the JWT for authenticated requests to your backend APIs\n- Re-initiate the Consent flow when a JWT is missing or expired\n\nWith this in place, your frontend is ready to authenticate Users and safely execute Vincent Tools on their behalf—within the boundaries they’ve configured through Vincent Policies.\n\n## Next Steps\n\n- Dive into the [Executing Vincent Tools]("
				},
				{
					"kind": "relative-link",
					"text": "./Executing-Tools.md",
					"target": 9
				},
				{
					"kind": "text",
					"text": ") guide to learn how to use the Vincent Tool Client to execute your App's Tool on behalf of an authenticated User\n- Explore the [Creating Vincent Tools]("
				},
				{
					"kind": "relative-link",
					"text": "../Tool-Developers/Getting-Started.md",
					"target": 4
				},
				{
					"kind": "text",
					"text": ") guide to learn how to create your own Vincent Tools\n- Explore the [Creating Vincent Policies]("
				},
				{
					"kind": "relative-link",
					"text": "../Policy-Developers/Creating-Policies.md",
					"target": 11
				},
				{
					"kind": "text",
					"text": ") guide to learn how to create your own Vincent Policies"
				}
			],
			"frontmatter": {
				"category": "Developers"
			}
		},
		{
			"id": 9,
			"name": "Executing Vincent Tools",
			"variant": "document",
			"kind": 8388608,
			"flags": {},
			"content": [
				{
					"kind": "text",
					"text": "# Using the Vincent Tool Client to Execute Tools\n\nAs a Vincent App Developer, you need a structured way to execute Vincent Tools for your Vincent App Users.\n\nThe Vincent App SDK provides a streamlined, type-safe interface called the Vincent Tool Client which manages the entire execution flow of a Vincent Tool. From handling the precheck validations to confirm all prerequisites are met and Tool execution is likely to succeed, to executing the Tool's logic to perform the permitted actions on behalf of the Vincent User.\n\nThis guide will walk you through the process of using the Tool Client to execute Vincent Tools.\n\n# How the Vincent Tool Client Works\n\nThe Vincent App SDK exports a function called "
				},
				{
					"kind": "code",
					"text": "`getVincentToolClient`"
				},
				{
					"kind": "text",
					"text": " that creates a wrapper around the Vincent Tool you'd like to execute on behalf of an App User. This function returns an instance of the Tool Client with two methods that are used to execute the Tool:\n\n1. **Precheck**: Executes the Vincent Tool's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function to provide quick and cost-free feedback on whether the Tool execution is likely to succeed. This function also:\n\n   - Validates the Tool parameters you provide against the Vincent Tool's requirements\n   - Evaluates the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function for any Vincent Policies the User has configured for your App\n     - **Note:** Execution of the Tool's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " logic will **not** happen unless all of the registered Vincent Policies pass their prechecks\n   - Returns the results of the Vincent Tool and Policy "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " functions, providing context on why the precheck logic has determined Tool execution is likely to succeed or fail\n\n2. **Execute**: Executes the Vincent Tool using the Lit Protocol network to perform the programmed tool actions on behalf of your App User. This function also:\n   - Validates Tool parameters and evaluates Policies registered by the User for your App\n     - **Note:** Execution of the Tool's logic will **not** happen unless all of the registered Policies permit execution\n   - Executes the "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " function of any Policies that have defined a "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " function\n     - **Note:** Policy "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " functions give each Policy the opportunity to update any state they depend on for their policy logic after the Tool has executed successfully (e.g. a spending limit policy would update the amount the App has spent on behalf of the Vincent User after the Tool has successfully transferred funds from the User's Agent Wallet)\n   - Returns the execution results of both the Tool and any evaluated Policies\n\n# Creating a Tool Client\n\nTo create an instance of the Tool Client, import the "
				},
				{
					"kind": "code",
					"text": "`getVincentToolClient`"
				},
				{
					"kind": "text",
					"text": " function from the "
				},
				{
					"kind": "code",
					"text": "`@lit-protocol/vincent-app-sdk`"
				},
				{
					"kind": "text",
					"text": " package. This function takes two parameters: a Vincent Tool definition and an ethers signer, returning an instance of the Tool Client.\n\nThe following code uses an example Vincent Tool package for reference:\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { ethers } from 'ethers';\nimport { getVincentToolClient } from '@lit-protocol/vincent-app-sdk';\nimport { bundledVincentTool } from '@example-org/vincent-tool-example-erc20-transfer';\n\nconst ethersSigner = new ethers.Wallet(process.env.VINCENT_APP_DELEGATEE_PRIVATE_KEY);\n\nconst toolClient = getVincentToolClient({\n  bundledVincentTool,\n  ethersSigner,\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\nThe two required parameters for the "
				},
				{
					"kind": "code",
					"text": "`getVincentToolClient`"
				},
				{
					"kind": "text",
					"text": " function are:\n\n1. "
				},
				{
					"kind": "code",
					"text": "`bundledVincentTool`"
				},
				{
					"kind": "text",
					"text": ": The definition of the Vincent Tool you want to execute on behalf of the App User, imported from a Vincent Tool package\n   - This tool definition is exported by the author of the Vincent Tool package and defines properties like the expected input parameters of the Tool, the Vincent Policies supported by the Tool, and the Tool's expected return values\n   - The Tool Client handles wrapping this tool definition, providing you with a simple interface for executing the Tool, abstracting away the complexity of the Tool's implementation\n2. "
				},
				{
					"kind": "code",
					"text": "`ethersSigner`"
				},
				{
					"kind": "text",
					"text": ": An Ethers.js signer that will be used to sign the request to execute the Tool using the Lit Protocol network\n   - **Note:** The corresponding Ethereum address of the signer **must** be added as a delegatee for the Vincent App you are executing the Tool for. You can see how to add a delegatee to your Vincent App [here]("
				},
				{
					"kind": "relative-link",
					"text": "./Quick-Start.md#2-registering-an-app-using-the-app-dashboard"
				},
				{
					"kind": "text",
					"text": ")\n\n# Executing the Tool Client's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function\n\nAfter creating an instance of the Tool Client, the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function is now configured and ready to be executed:\n\n> **Note:** While not mandatory, it's recommended to execute the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function before every execution of the Tool Client's "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function as it's quick, cost-free, and can provide important context on the current state that the Tool and it's Policies depend on (e.g. the amount of funds left to spend for a spending limit policy).\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { ethers } from 'ethers';\nimport { getVincentToolClient } from '@lit-protocol/vincent-app-sdk';\nimport { bundledVincentTool } from '@example-org/vincent-tool-example-erc20-transfer';\n\nconst ethersSigner = new ethers.Wallet(process.env.VINCENT_APP_DELEGATEE_PRIVATE_KEY);\n\nconst toolClient = getVincentToolClient({\n  bundledVincentTool,\n  ethersSigner,\n});\n\nconst precheckResult = await toolClient.precheck({\n  toolParams: {\n    tokenAddress: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', // USDC on Base\n    recipientAddress: '0x1234567890123456789012345678901234567890',\n    amount: 100,\n  },\n  context: {\n    // The ETH address of the App User's Agent Wallet you are executing the Tool on behalf of\n    delegatorPkpEthAddress: '0x1234567890123456789012345678901234567890',\n  },\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\nThe "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function takes two arguments:\n\n1. An object that contains the input parameters for the Tool that has the structure of the Tool's Zod schema: "
				},
				{
					"kind": "code",
					"text": "`ToolParamsSchema`"
				},
				{
					"kind": "text",
					"text": "\n\n> **Note:** Because Vincent Tool definitions are strongly typed, your code editor should display the expected input parameters for the Tool\n>\n> If for whatever reason the type inference is not working, check the Tool's documentation for the expected input parameters\n\n2. An object that contains:\n   - "
				},
				{
					"kind": "code",
					"text": "`rpcUrl`"
				},
				{
					"kind": "text",
					"text": ": An optional parameter to override the default RPC URL used to communicate with the Lit Protocol network\n     - This RPC URL is used to fetch the on-chain data about your Vincent App, what App Version (if any) the Vincent User has authorized, and the on-chain Policy parameters configured by the User for your App\n     - Most developers do **not** need to provide this property, and the default RPC URL should be used\n   - "
				},
				{
					"kind": "code",
					"text": "`delegatorPkpEthAddress`"
				},
				{
					"kind": "text",
					"text": ": A required parameter that is the Ethereum address of the App User's Agent Wallet you'll be executing the Tool on behalf of\n\n## Precheck Results\n\n<!-- TODO Link to PrecheckSuccessSchema typedoc interface when it's available -->\n\nThe return type of the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function depends on the overall success or failure of the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function, as well as the results of any evaluated Policies. If all Policies are expecting to permit Tool execution, and the Tool's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function is expecting Tool execution to succeed, the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function will return a "
				},
				{
					"kind": "code",
					"text": "`ToolResponse`"
				},
				{
					"kind": "text",
					"text": " with a success result that has the structure of the Tool's Zod schema: "
				},
				{
					"kind": "code",
					"text": "`PrecheckSuccessSchema`"
				},
				{
					"kind": "text",
					"text": ".\n\nIf "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " returns a success result, you can execute the Tool's "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function with reasonable confidence that the Tool should execute successfully.\n\n<!-- TODO Link to PrecheckFailSchema typedoc interface when it's available -->\n\nHowever, if one of the evaluated Policies returns a deny response, signifying it's expecting to deny Tool execution, or all Policies permit execution, but the Tool's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function is expecting Tool execution to fail, the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function will return a "
				},
				{
					"kind": "code",
					"text": "`ToolResponse`"
				},
				{
					"kind": "text",
					"text": " with a failure result that has the structure of the Tool's Zod schema: "
				},
				{
					"kind": "code",
					"text": "`PrecheckFailSchema`"
				},
				{
					"kind": "text",
					"text": ".\n\nIf "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " returns a failure result, you should check the "
				},
				{
					"kind": "code",
					"text": "`error`"
				},
				{
					"kind": "text",
					"text": " property on the result object to see if there was a known error that occurred during the execution of the Tool's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function. Additionally, if one of the evaluated Polices has denied Tool execution, you should check the result object's "
				},
				{
					"kind": "code",
					"text": "`context.policiesContext`"
				},
				{
					"kind": "text",
					"text": " property to see which Policy denied Tool execution and why.\n\n# Executing the Tool Client's "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function\n\n<div class=\"info-box\">\n  <p class=\"info-box-title\">\n    <span class=\"info-icon\">Info</span> Before executing the Tool\n  </p>\n  <p>Executing a Tool using the Lit Protocol network requires a <a href=\"https://developer.litprotocol.com/paying-for-lit/capacity-credits\">Lit Capacity Credit</a> minted for the Ethereum Address you're using for the "
				},
				{
					"kind": "code",
					"text": "`ethersSigner`"
				},
				{
					"kind": "text",
					"text": " when creating the Tool Client instance with "
				},
				{
					"kind": "code",
					"text": "`getVincentToolClient`"
				},
				{
					"kind": "text",
					"text": ".</p>\n  <p>In order to mint a Capacity Credit, you'll need to have tokens on Lit Protocol's Yellowstone blockchain. You can use <a href=\"https://chronicle-yellowstone-faucet.getlit.dev/\">this faucet</a> to get the Lit test tokens used to pay for minting a Capacity Credit.</p>\n  <p>To mint a Capacity Credit using the Lit Explorer, please see <a href=\"https://developer.litprotocol.com/paying-for-lit/minting-capacity-credit/via-explorer\">this guide</a>. To mint a Credit programmatically, refer to <a href=\"https://developer.litprotocol.com/paying-for-lit/minting-capacity-credit/via-contract\">this guide</a>.</p>\n</div>\n\nAfter executing the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function and getting a success result, you can execute the Tool Client's "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function to perform the programmed action of the Vincent Tool.\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { ethers } from 'ethers';\nimport { getVincentToolClient } from '@lit-protocol/vincent-app-sdk';\nimport { bundledVincentTool } from '@example-org/vincent-tool-example-erc20-transfer';\n\nconst ethersSigner = new ethers.Wallet(process.env.VINCENT_APP_DELEGATEE_PRIVATE_KEY);\n\nconst toolClient = getVincentToolClient({\n  bundledVincentTool,\n  ethersSigner,\n});\n\nconst executeResult = await toolClient.execute({\n  toolParams: {\n    tokenAddress: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', // USDC on Base\n    recipientAddress: '0x1234567890123456789012345678901234567890',\n    amount: 100,\n  },\n  context: {\n    // The ETH address of the Agent Wallet you are executing the Tool on behalf of\n    delegatorPkpEthAddress: '0x1234567890123456789012345678901234567890',\n  },\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\nThe "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function takes two arguments similar to the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function:\n\n1. An object that contains the input parameters for the Tool that has the structure of the Tool's Zod schema: "
				},
				{
					"kind": "code",
					"text": "`ToolParamsSchema`"
				},
				{
					"kind": "text",
					"text": "\n\n> **Note:** Because Vincent Tool definitions are strongly typed, your code editor should display the expected input parameters for the Tool\n>\n> If for whatever reason the type inference is not working, check the Tool's documentation for the expected input parameters\n\n2. An object that contains:\n   - "
				},
				{
					"kind": "code",
					"text": "`delegatorPkpEthAddress`"
				},
				{
					"kind": "text",
					"text": ": A required parameter that is the Ethereum address of the Vincent User's Agent Wallet you'll be executing the Tool on behalf of\n\n## Execute Results\n\nThe return type of the "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function depends on whether all evaluated Policies permitted Tool execution, as well as if the Tool's execution was successful.\n\nIf one of the Policies returns a deny response, or an error occurs during the execution of the Tool's logic, the "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function will return a failure result with the structure of the Tool's Zod schema: "
				},
				{
					"kind": "code",
					"text": "`ExecuteFailSchema`"
				},
				{
					"kind": "text",
					"text": ".\n\nAdditionally, Vincent Policies have an optional "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " function (as covered in the [How Vincent Policies Work](#how-the-tool-client-sdk-works) section), which is executed for each Policy that has defined a "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " function after the Tool's logic is executed successfully. If one of the "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " functions were to fail during execution or return a deny response, the "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function will return a failure result.\n\nIf all evaluated Policies permit execution, the Tool's execution is successful, and all the Policy "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " functions are executed successfully, the "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function will return a success result with the structure of the Tool's Zod schema: "
				},
				{
					"kind": "code",
					"text": "`ExecuteSuccessSchema`"
				},
				{
					"kind": "text",
					"text": ".\n\n# Wrapping Up\n\nYou now have a complete understanding of how to execute Vincent Tools using the Tool Client. From running prechecks to evaluate Tool readiness, to executing Tools on behalf of App Users with Policy-enforced constraints, the Tool Client simplifies the full lifecycle of Vincent Tool execution.\n\nAs a quick recap:\n\n- Import the "
				},
				{
					"kind": "code",
					"text": "`bundledVincentTool`"
				},
				{
					"kind": "text",
					"text": " tool definition from the Vincent Tool package you're using\n- Use "
				},
				{
					"kind": "code",
					"text": "`getVincentToolClient`"
				},
				{
					"kind": "text",
					"text": " to create an instance of the Tool Client for a specific Vincent Tool\n- Always run the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " method first to validate Tool parameters, ensure all user-configured Vincent Policies permit execution, and check whether the Tool's execution is likely to succeed\n- If the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " passes, use the "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " method on the Tool Client to execute the Tool’s logic\n- After successful execution of the Tool's logic, any evaluated Vincent Policies with commit functions will automatically update their internal state, keeping your App compliant with the User's defined Policy limits\n\n## Next Steps\n\nIf you're interested in creating your own Vincent Tool and Policies, checkout the [Creating Tools]("
				},
				{
					"kind": "relative-link",
					"text": "./Creating-Tools.md"
				},
				{
					"kind": "text",
					"text": ") and [Creating Policies]("
				},
				{
					"kind": "relative-link",
					"text": "./Creating-Policies.md"
				},
				{
					"kind": "text",
					"text": ") guides."
				}
			],
			"frontmatter": {
				"category": "Developers"
			}
		},
		{
			"id": 10,
			"name": "Creating Vincent Tools",
			"variant": "document",
			"kind": 8388608,
			"flags": {},
			"content": [
				{
					"kind": "text",
					"text": "# How a Vincent Tool Works\n\nA Vincent Tool consists of two main lifecycle methods executed in the following order:\n\n1. **Precheck**: Executed locally by the Vincent Tool executor, this function provides a best-effort check that the tool execution shouldn't fail\n\n   - Before the execution of your tool's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function, the Vincent Tool SDK will execute the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " functions of the Vincent Policies\n   - If all Vincent Policies return "
				},
				{
					"kind": "code",
					"text": "`allow`"
				},
				{
					"kind": "text",
					"text": " results, the Vincent Tool's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function will be executed\n   - This function is where you'd perform checks such as validating the Vincent Agent Wallet has sufficient token balances, has the appropriate on-chain approvals to make token transfers, or anything else your tool can validate before executing the tool's logic\n\n2. **Execute**: Executed within the Lit Action environment, this function performs the actual tool logic and has the ability to sign data using the Vincent App User's Agent Wallet\n   - Before the execution of your tool's "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function, the Vincent Tool SDK will execute the "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": " functions of the Vincent Policies\n   - If all Vincent Policies return "
				},
				{
					"kind": "code",
					"text": "`allow`"
				},
				{
					"kind": "text",
					"text": " results, the Vincent Tool's "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function will be executed\n   - This function is where you'd perform the actual tool logic, such as making token transfers, interacting with smart contracts, or anything else your tool needs to do to fulfill the tool's purpose\n\n# Defining Your Vincent Tool\n\nVincent Tools are created by calling the "
				},
				{
					"kind": "code",
					"text": "`createVincentTool`"
				},
				{
					"kind": "text",
					"text": " function from the "
				},
				{
					"kind": "code",
					"text": "`@lit-protocol/vincent-tool-sdk`"
				},
				{
					"kind": "text",
					"text": " package. This function takes a single object parameter that defines your tool's lifecycle methods, parameter schemas, return value schemas, and supported policies.\n\nThe following is the basic structure of a Vincent Tool definition:\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nexport const vincentTool = createVincentTool({\n  toolParamsSchema,\n\n  supportedPolicies: supportedPoliciesForTool([]),\n\n  precheckSuccessSchema,\n  precheckFailSchema,\n  precheck: async ({ toolParams }, toolContext) => {},\n\n  executeSuccessSchema,\n  executeFailSchema,\n  execute: async ({ toolParams }, toolContext) => {},\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\n## The "
				},
				{
					"kind": "code",
					"text": "`toolContext`"
				},
				{
					"kind": "text",
					"text": " Argument\n\nThe "
				},
				{
					"kind": "code",
					"text": "`toolContext`"
				},
				{
					"kind": "text",
					"text": " argument is provided and managed by the Vincent Tool SDK. It's an object containing the following properties and is passed as an argument to your tool's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " and "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " functions:\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\ninterface ToolContext {\n  toolIpfsCid: string;\n  appId: number;\n  appVersion: number;\n  delegation: {\n    delegateeAddress: string;\n    delegatorPkpInfo: {\n      tokenId: string;\n      ethAddress: string;\n      publicKey: string;\n    };\n  };\n  policiesContext: {\n    allow: boolean;\n    allowedPolicies: {\n      [policyPackageName: string]: {\n        result: evalAllowResultSchema;\n        commit: (\n          params: commitParamsSchema,\n        ) => Promise<commitAllowResultSchema | commitDenyResultSchema>;\n      };\n    };\n    deniedPolicy?: {\n      policyPackageName: string;\n      result: evalDenyResultSchema;\n    };\n  };\n  succeed: (executeSuccessResult: executeSuccessSchema) => void;\n  fail: (executeFailResult: executeFailSchema) => void;\n}\n```"
				},
				{
					"kind": "text",
					"text": "\n\nWhere:\n\n- "
				},
				{
					"kind": "code",
					"text": "`toolIpfsCid`"
				},
				{
					"kind": "text",
					"text": ": The IPFS CID of the Vincent Tool that is being executed\n- "
				},
				{
					"kind": "code",
					"text": "`appId`"
				},
				{
					"kind": "text",
					"text": ": The ID of the Vincent App the Vincent Tool is being executed for\n- "
				},
				{
					"kind": "code",
					"text": "`appVersion`"
				},
				{
					"kind": "text",
					"text": ": The version of the Vincent App the Vincent Tool is being executed for\n- "
				},
				{
					"kind": "code",
					"text": "`delegation`"
				},
				{
					"kind": "text",
					"text": ":\n  - "
				},
				{
					"kind": "code",
					"text": "`delegateeAddress`"
				},
				{
					"kind": "text",
					"text": ": The Ethereum address of the Vincent Tool executor\n  - "
				},
				{
					"kind": "code",
					"text": "`delegatorPkpInfo`"
				},
				{
					"kind": "text",
					"text": ":\n    - "
				},
				{
					"kind": "code",
					"text": "`tokenId`"
				},
				{
					"kind": "text",
					"text": ": The token ID of the Vincent App User's Vincent Agent Wallet\n    - "
				},
				{
					"kind": "code",
					"text": "`ethAddress`"
				},
				{
					"kind": "text",
					"text": ": The Ethereum address of the Vincent App User's Vincent Agent Wallet\n    - "
				},
				{
					"kind": "code",
					"text": "`publicKey`"
				},
				{
					"kind": "text",
					"text": ": The public key of the Vincent App User's Vincent Agent Wallet\n- "
				},
				{
					"kind": "code",
					"text": "`policiesContext`"
				},
				{
					"kind": "text",
					"text": ": An object containing the results of each evaluated Vincent Policy\n  - "
				},
				{
					"kind": "code",
					"text": "`allow`"
				},
				{
					"kind": "text",
					"text": ": A boolean indicating if the Vincent Tool execution is allowed to proceed, and all evaluated Vincent Policies returned "
				},
				{
					"kind": "code",
					"text": "`allow`"
				},
				{
					"kind": "text",
					"text": " results\n  - "
				},
				{
					"kind": "code",
					"text": "`allowedPolicies`"
				},
				{
					"kind": "text",
					"text": ": An object containing the results and "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " functions for each Vincent Policy that permitted tool execution\n    - "
				},
				{
					"kind": "code",
					"text": "`[policyPackageName]`"
				},
				{
					"kind": "text",
					"text": ": An object where the key is the package name of the Vincent Policy, and the value is an object containing the result of the policy's "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": " function and the policy's "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " function if it exists\n      - "
				},
				{
					"kind": "code",
					"text": "`result`"
				},
				{
					"kind": "text",
					"text": ": An object will details describing why the policy has permitted tool execution. This will have the shape of the Vincent Policy's [evalAllowResultSchema]("
				},
				{
					"kind": "relative-link",
					"text": "./Creating-Policies.md#evalallowresultschema"
				},
				{
					"kind": "text",
					"text": ")\n      - "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": ": An optional function for each evaluated Vincent Policy that allows the policy to update any state it depends on to make it's decisions\n        - The parameter object passed to the "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " function is defined by each Vincent Policy's [commitParamsSchema]("
				},
				{
					"kind": "relative-link",
					"text": "./Creating-Policies.md#commitparamsschema"
				},
				{
					"kind": "text",
					"text": "), and the return value is defined by the policy's [commitAllowResultSchema]("
				},
				{
					"kind": "relative-link",
					"text": "./Creating-Policies.md#commitallowresultschema"
				},
				{
					"kind": "text",
					"text": ") or [commitDenyResultSchema]("
				},
				{
					"kind": "relative-link",
					"text": "./Creating-Policies.md#commitdenyresultschema"
				},
				{
					"kind": "text",
					"text": ")\n  - "
				},
				{
					"kind": "code",
					"text": "`deniedPolicy`"
				},
				{
					"kind": "text",
					"text": ": An object containing the first Vincent Policy that denied the Vincent Tool execution\n    - "
				},
				{
					"kind": "code",
					"text": "`policyPackageName`"
				},
				{
					"kind": "text",
					"text": ": The package name of the Vincent Policy that denied the Vincent Tool execution\n    - "
				},
				{
					"kind": "code",
					"text": "`result`"
				},
				{
					"kind": "text",
					"text": ": The result of the "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": " function of the Vincent Policy that denied the Vincent Tool execution, will have the shape of the Vincent Policy's [evalDenyResultSchema]("
				},
				{
					"kind": "relative-link",
					"text": "./Creating-Policies.md#evaldenyresultschema"
				},
				{
					"kind": "text",
					"text": ")\n- "
				},
				{
					"kind": "code",
					"text": "`succeed`"
				},
				{
					"kind": "text",
					"text": ": A helper method for returning a "
				},
				{
					"kind": "code",
					"text": "`success`"
				},
				{
					"kind": "text",
					"text": " result from your tool's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " and "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " functions\n- "
				},
				{
					"kind": "code",
					"text": "`fail`"
				},
				{
					"kind": "text",
					"text": ": A helper method for returning a "
				},
				{
					"kind": "code",
					"text": "`fail`"
				},
				{
					"kind": "text",
					"text": " result from your tool's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " and "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " functions\n\n## Parameter Schemas\n\n### "
				},
				{
					"kind": "code",
					"text": "`toolParamsSchema`"
				},
				{
					"kind": "text",
					"text": "\n\nThis Zod schema defines the structure of parameters that executors will provide to your tool. These should be the parameters you require to execute your tool's functionality, as well as any parameters required by the Vincent Policies your tool supports.\n\nFor example, if you are building a token transfer tool that supports a Vincent spending limit policy, you might define the "
				},
				{
					"kind": "code",
					"text": "`toolParamsSchema`"
				},
				{
					"kind": "text",
					"text": " as follows:\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { createVincentTool } from '@lit-protocol/vincent-tool-sdk';\nimport { z } from 'zod';\n\nconst toolParamsSchema = z.object({\n  tokenAddress: z.string(),\n  amountToSend: z.number(),\n  recipientAddress: z.string(),\n});\n\nconst vincentTool = createVincentTool({\n  // ... other tool definitions\n\n  toolParamsSchema,\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\nThese parameters give your tool what it needs to send a transaction transferring "
				},
				{
					"kind": "code",
					"text": "`amountToSend`"
				},
				{
					"kind": "text",
					"text": " of "
				},
				{
					"kind": "code",
					"text": "`tokenAddress`"
				},
				{
					"kind": "text",
					"text": " to "
				},
				{
					"kind": "code",
					"text": "`recipientAddress`"
				},
				{
					"kind": "text",
					"text": ".\n\nThe "
				},
				{
					"kind": "code",
					"text": "`tokenAddress`"
				},
				{
					"kind": "text",
					"text": " and "
				},
				{
					"kind": "code",
					"text": "`amountToSend`"
				},
				{
					"kind": "text",
					"text": " parameters are also the parameters required to be given to the Vincent spending limit policy which we'll cover in the next section.\n\n## Defining Supported Policies\n\n<!-- TODO Link to the VincentToolPolicy typedoc interface when it's available -->\n\nTo add support for Vincent Policies to your tool, you need to create Vincent Tool Policy objects using the "
				},
				{
					"kind": "code",
					"text": "`createVincentToolPolicy`"
				},
				{
					"kind": "text",
					"text": " function from the "
				},
				{
					"kind": "code",
					"text": "`@lit-protocol/vincent-tool-sdk`"
				},
				{
					"kind": "text",
					"text": " package for each Vincent Policy you want your tool to support. These Vincent Tool Policy objects are then added to your tool's "
				},
				{
					"kind": "code",
					"text": "`supportedPolicies`"
				},
				{
					"kind": "text",
					"text": " array, which binds the policies to your tool and enables proper parameter mapping between your tool and the policies.\n\n> **Note:** Supporting a Vincent Policy does not mean the policy is required to be used with your tool, it means the Vincent App developer that uses your tool can enabled the supported policies for use by their Vincent App Users, if the App User chooses to enable those policies.\n\n### Creating a "
				},
				{
					"kind": "code",
					"text": "`VincentToolPolicy`"
				},
				{
					"kind": "text",
					"text": " object\n\nOur example Vincent Tool supports a Vincent spending limit policy that has the following schema for the parameters it's expecting to be given by the executing Vincent Tool:\n\n> **Note** The following code is an excerpt from the [Create a Vincent Policy]("
				},
				{
					"kind": "relative-link",
					"text": "./Creating-Policies.md#userparamsschema"
				},
				{
					"kind": "text",
					"text": ") guide.\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { createVincentPolicy } from '@lit-protocol/vincent-tool-sdk';\nimport { z } from 'zod';\n\nconst vincentPolicy = createVincentPolicy({\n  // ... other policy definitions\n\n  toolParamsSchema: z.object({\n    tokenAddress: z.string(),\n    amount: z.number(),\n  }),\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\nAs the Vincent Tool developer, what this means is that both your "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " and "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " functions need to pass a "
				},
				{
					"kind": "code",
					"text": "`tokenAddress`"
				},
				{
					"kind": "text",
					"text": " and "
				},
				{
					"kind": "code",
					"text": "`amount`"
				},
				{
					"kind": "text",
					"text": " parameter to the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " and "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " functions of the Vincent spending limit policy.\n\nBecause the name of the parameters given to your tool, as defined by your tool's "
				},
				{
					"kind": "code",
					"text": "`toolParamsSchema`"
				},
				{
					"kind": "text",
					"text": ", won't always be named the same as or even refer to the same thing as the Vincent Policies your tool supports, we need a way to map the parameters given to your tool to the parameters expected by the Vincent Policies.\n\nTo accomplish this, we create a _VincentToolPolicy_ object using the "
				},
				{
					"kind": "code",
					"text": "`createVincentToolPolicy`"
				},
				{
					"kind": "text",
					"text": " function:\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport {\n  createVincentTool,\n  createVincentToolPolicy,\n  supportedPoliciesForTool,\n} from '@lit-protocol/vincent-tool-sdk';\nimport { bundledVincentPolicy } from '@lit-protocol/vincent-policy-spending-limit';\nimport { z } from 'zod';\n\nconst toolParamsSchema = z.object({\n  tokenAddress: z.string(),\n  amountToSend: z.number(),\n  recipientAddress: z.string(),\n});\n\nconst SpendingLimitPolicy = createVincentToolPolicy({\n  toolParamsSchema,\n  bundledVincentPolicy,\n  toolParameterMappings: {\n    tokenAddress: 'tokenAddress',\n    amountToSend: 'amount',\n  },\n});\n\nconst vincentTool = createVincentTool({\n  // ... other tool definitions\n\n  toolParamsSchema,\n\n  supportedPolicies: supportedPoliciesForTool([SpendingLimitPolicy]),\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\nA couple of new things are happening in this code example:\n\nFirst we're importing "
				},
				{
					"kind": "code",
					"text": "`bundledVincentPolicy`"
				},
				{
					"kind": "text",
					"text": " from the "
				},
				{
					"kind": "code",
					"text": "`@lit-protocol/vincent-policy-spending-limit`"
				},
				{
					"kind": "text",
					"text": " package, which is a Vincent Policy object created using the Vincent Tool SDK and exported by the policy author for Vincent Tools to consume.\n\nThen we're creating a "
				},
				{
					"kind": "code",
					"text": "`VincentToolPolicy`"
				},
				{
					"kind": "text",
					"text": " object named "
				},
				{
					"kind": "code",
					"text": "`SpendingLimitPolicy`"
				},
				{
					"kind": "text",
					"text": " using the "
				},
				{
					"kind": "code",
					"text": "`createVincentToolPolicy`"
				},
				{
					"kind": "text",
					"text": " function. The "
				},
				{
					"kind": "code",
					"text": "`createVincentToolPolicy`"
				},
				{
					"kind": "text",
					"text": " function takes a single object parameter with the required properties:\n\n- "
				},
				{
					"kind": "code",
					"text": "`toolParamsSchema`"
				},
				{
					"kind": "text",
					"text": ": The Zod schema (covered in the [Parameter Schemas](#parameter-schemas) section) you've defined for the parameters your tool expects to be given by the Vincent Tool executor\n- "
				},
				{
					"kind": "code",
					"text": "`bundledVincentPolicy`"
				},
				{
					"kind": "text",
					"text": ": The Vincent Policy object created by the policy author for Vincent Tools to consume, which is imported from the "
				},
				{
					"kind": "code",
					"text": "`@lit-protocol/vincent-policy-spending-limit`"
				},
				{
					"kind": "text",
					"text": " package\n- "
				},
				{
					"kind": "code",
					"text": "`toolParameterMappings`"
				},
				{
					"kind": "text",
					"text": ": An object that maps the parameters given to your tool to the parameters expected by the Vincent Policy you're supporting\n  - The keys of this object are the parameter names your tool uses ("
				},
				{
					"kind": "code",
					"text": "`tokenAddress`"
				},
				{
					"kind": "text",
					"text": " and "
				},
				{
					"kind": "code",
					"text": "`amountToSend`"
				},
				{
					"kind": "text",
					"text": "), and the values are the parameter names expected by the Vincent Policy ("
				},
				{
					"kind": "code",
					"text": "`tokenAddress`"
				},
				{
					"kind": "text",
					"text": " and "
				},
				{
					"kind": "code",
					"text": "`amount`"
				},
				{
					"kind": "text",
					"text": ")\n\nLastly, we take the "
				},
				{
					"kind": "code",
					"text": "`SpendingLimitPolicy`"
				},
				{
					"kind": "text",
					"text": " object and add it to an array, which we then wrap in a "
				},
				{
					"kind": "code",
					"text": "`supportedPoliciesForTool`"
				},
				{
					"kind": "text",
					"text": " function call to our tool's "
				},
				{
					"kind": "code",
					"text": "`supportedPolicies`"
				},
				{
					"kind": "text",
					"text": " array.\n\nThis is how we register the "
				},
				{
					"kind": "code",
					"text": "`SpendingLimitPolicy`"
				},
				{
					"kind": "text",
					"text": " with our tool. That's all that's needed for your tool to support the Vincent spending limit policy. The execution of the policy's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " and "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": " functions will be handled for you by the Vincent Tool SDK, as well as processing the return values from the policy's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " and "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": " functions to check if the tool should be allowed to execute.\n\n## Precheck Function\n\nThe "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function is executed locally by the Vincent Tool executor to provide a best-effort check that the tool execution shouldn't fail when the "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function is called.\n\nExecuting a Vincent Tool's "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function uses the Lit network, which costs both time and money, so your "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function should perform whatever validation it can to ensure that the tool won't fail during execution.\n\nBefore executing your tool's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function, the Vincent Tool SDK will execute the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " functions of any Vincent Policies registered by the Vincent User. If all policies return "
				},
				{
					"kind": "code",
					"text": "`allow`"
				},
				{
					"kind": "text",
					"text": " results, the Vincent Tool's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function will be executed.\n\nFor our example token transfer tool, the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function checks both the Vincent User's Agent Wallet ERC20 token balance, as well as the native token balance to validate the Agent Wallet has enough balance to perform the token transfer and pay for the gas fees of the transfer transaction.\n\n> **Note:** The code from the previous sections has been omitted for brevity. The full code example can be found in the [Wrapping Up](#wrapping-up) section at the end of this guide.\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { createVincentTool } from '@lit-protocol/vincent-tool-sdk';\n\nimport {\n  createErc20TransferTransaction,\n  getErc20TokenBalance,\n  getNativeTokenBalance,\n} from './my-tool-code';\n\nconst vincentTool = createVincentTool({\n  // ... other tool definitions\n\n  precheck: async ({ toolParams }, toolContext) => {\n    const { tokenAddress, amountToSend, recipientAddress } = toolParams;\n\n    const erc20TokenBalance = await getErc20TokenBalance(\n      toolContext.delegation.delegatorPkpInfo.ethAddress,\n      tokenAddress,\n      amountToSend,\n    );\n    if (erc20TokenBalance < amountToSend) {\n      return toolContext.fail({\n        reason: 'Insufficient token balance',\n        currentBalance: erc20TokenBalance,\n        requiredAmount: amountToSend,\n      });\n    }\n\n    const transferTransaction = createErc20TransferTransaction(\n      tokenAddress,\n      recipientAddress,\n      amountToSend,\n    );\n\n    let estimatedGas;\n    try {\n      // Gas estimation might fail if transaction would revert\n      estimatedGas = await transferTransaction.estimateGas();\n    } catch (error) {\n      // Handle gas estimation failures (transaction would revert)\n      if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {\n        return toolContext.fail({\n          reason: 'Transaction reverted during gas estimation/transaction simulation',\n          errorCode: error.code,\n          revertReason: error.reason || 'Unknown revert reason',\n          transferTransaction,\n        });\n      }\n\n      // Let the Vincent Tool SDK handle the error\n      throw error;\n    }\n\n    const nativeTokenBalance = await getNativeTokenBalance(\n      toolContext.delegation.delegatorPkpInfo.ethAddress,\n      estimatedGas,\n    );\n\n    if (nativeTokenBalance < estimatedGas) {\n      return toolContext.fail({\n        reason: 'Insufficient native token balance',\n        currentBalance: nativeTokenBalance,\n        requiredAmount: estimatedGas,\n      });\n    }\n\n    return toolContext.succeed({\n      erc20TokenBalance,\n      nativeTokenBalance,\n      estimatedGas,\n    });\n  },\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\nTwo arguments are passed to your tool's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function by the Vincent Tool SDK. The first is an object containing the "
				},
				{
					"kind": "code",
					"text": "`toolParams`"
				},
				{
					"kind": "text",
					"text": " the adhere to the "
				},
				{
					"kind": "code",
					"text": "`toolParamsSchema`"
				},
				{
					"kind": "text",
					"text": " you have defined for your tool. The second is the ["
				},
				{
					"kind": "code",
					"text": "`toolContext`"
				},
				{
					"kind": "text",
					"text": "](#the-toolcontext-argument) managed by the Vincent Tool SDK that contains helper methods for returning "
				},
				{
					"kind": "code",
					"text": "`succeed`"
				},
				{
					"kind": "text",
					"text": " and "
				},
				{
					"kind": "code",
					"text": "`fail`"
				},
				{
					"kind": "text",
					"text": " results, as well as some metadata about the Vincent App that the tool is being executed for.\n\n### "
				},
				{
					"kind": "code",
					"text": "`precheckSuccessSchema`"
				},
				{
					"kind": "text",
					"text": "\n\nThis Zod schema defines the structure of successful "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " results. What's included in the returned object is up to you, but ideally it includes details about why the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " passed.\n\nThe following schema returns useful information to the Vincent Tool executor about the current balances of the Agent Wallet, as well as the estimated gas cost of the transaction:\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { createVincentTool } from '@lit-protocol/vincent-tool-sdk';\nimport { z } from 'zod';\n\nconst vincentTool = createVincentTool({\n  // ... other tool definitions\n\n  precheckSuccessSchema: z.object({\n    erc20TokenBalance: z.number(),\n    nativeTokenBalance: z.number(),\n    estimatedGas: z.number(),\n  }),\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\n### "
				},
				{
					"kind": "code",
					"text": "`precheckFailSchema`"
				},
				{
					"kind": "text",
					"text": "\n\nThis Zod schema defines the structure of a failed "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " result. What's included in the returned object is up to you, but ideally it includes details about why the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " failed.\n\nThe following schema returns additional information to the Vincent Tool executor that would help them understand why the tool execution would fail. In this case, the "
				},
				{
					"kind": "code",
					"text": "`reason`"
				},
				{
					"kind": "text",
					"text": " string allows the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function to return a specific error message stating something like "
				},
				{
					"kind": "code",
					"text": "`\"Insufficient token balance\"`"
				},
				{
					"kind": "text",
					"text": " or "
				},
				{
					"kind": "code",
					"text": "`\"Insufficient native token balance\"`"
				},
				{
					"kind": "text",
					"text": ", along with current and required amounts for debugging:\n\n> **Note:** If any unhandled error occurs during execution of your tool's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function, the Vincent Tool SDK will automatically return a "
				},
				{
					"kind": "code",
					"text": "`fail`"
				},
				{
					"kind": "text",
					"text": " result with the error message.\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { createVincentTool } from '@lit-protocol/vincent-tool-sdk';\nimport { z } from 'zod';\n\nconst vincentTool = createVincentTool({\n  // ... other tool definitions\n\n  precheckFailSchema: z.object({\n    reason: z.string(),\n    currentBalance: z.number().optional(),\n    requiredAmount: z.number().optional(),\n  }),\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\n## Execute Function\n\nThe "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function is the main logic of your Vincent Tool, executed within the Lit Action environment when the Vincent Tool executor wants to perform the actual tool operation on behalf of the Vincent App User.\n\nUnlike the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function which only validates feasibility, the "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function performs the actual work your tool is designed to do. Additionally, because the "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function is executed in the Lit Action environment, it has access to the full Lit Action capabilities, including the ability to sign transactions and data using the Vincent App User's Agent Wallet (for more information on what's available to you within the Lit Action environment see the Lit Protocol [Lit Action](https://developer.litprotocol.com/sdk/serverless-signing/overview) docs).\n\n> **Note** This [Lit Action](https://developer.litprotocol.com/sdk/serverless-signing/combining-signatures) doc page covers how to sign data with a PKP using the Ethers.js library within a Lit Action. Ethers.js is injected by Lit into the Lit Action runtime, so you don't need to import it to use it within your tool's "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function.\n\nBefore executing your tool's "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function, the Vincent Tool SDK will execute the "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": " functions of any Vincent Policies registered by the Vincent User. If all policies return "
				},
				{
					"kind": "code",
					"text": "`allow`"
				},
				{
					"kind": "text",
					"text": " results, your tool's "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function will be executed.\n\nFor our example token transfer tool, the "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function performs the actual ERC20 token transfer transaction:\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { createVincentTool } from '@lit-protocol/vincent-tool-sdk';\n\nimport { createErc20TransferTransaction } from './my-tool-code';\n\nconst vincentTool = createVincentTool({\n  // ... other tool definitions\n\n  execute: async ({ toolParams }, toolContext) => {\n    const { tokenAddress, amountToSend, recipientAddress } = toolParams;\n\n    const transferTransaction = createErc20TransferTransaction(\n      tokenAddress,\n      recipientAddress,\n      amountToSend,\n    );\n\n    try {\n      // Estimate gas to catch potential revert reasons early\n      const estimatedGas = await transferTransaction.estimateGas();\n    } catch (error) {\n      // Handle different types of errors\n      if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {\n        return toolContext.fail({\n          error: 'Transaction reverted during gas estimation/transaction simulation',\n          errorCode: error.code,\n          revertReason: error.reason || 'Unknown revert reason',\n          transferTransaction,\n        });\n      }\n\n      // Let the Vincent Tool SDK handle the error\n      throw error;\n    }\n\n    const transferTransactionHash = await transferTransaction.send();\n    return toolContext.succeed({\n      transferTransactionHash,\n    });\n  },\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\nTwo arguments are passed to your tool's "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function by the Vincent Tool SDK. The first is an object containing the "
				},
				{
					"kind": "code",
					"text": "`toolParams`"
				},
				{
					"kind": "text",
					"text": " the adhere to the "
				},
				{
					"kind": "code",
					"text": "`toolParamsSchema`"
				},
				{
					"kind": "text",
					"text": " you have defined for your tool. The second is the ["
				},
				{
					"kind": "code",
					"text": "`toolContext`"
				},
				{
					"kind": "text",
					"text": "](#the-toolcontext-argument) managed by the Vincent Tool SDK that contains helper methods for returning "
				},
				{
					"kind": "code",
					"text": "`succeed`"
				},
				{
					"kind": "text",
					"text": " and "
				},
				{
					"kind": "code",
					"text": "`fail`"
				},
				{
					"kind": "text",
					"text": " results, as well as some metadata about the Vincent App that the tool is being executed for.\n\n### "
				},
				{
					"kind": "code",
					"text": "`executeSuccessSchema`"
				},
				{
					"kind": "text",
					"text": "\n\nThis Zod schema defines the structure of a successful "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " result. What's included in the returned object is up to you, but ideally it includes details about why the "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function is allowing the Vincent Tool execution.\n\nThe following schema returns to the Vincent Tool executor the transaction hash of the executed transaction, and the hash for the transaction sent during the execution of the Vincent spending limit policy's "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " function to update the amount of tokens spent (this is covered further in the [Executing Vincent Policy Commit Functions](#executing-vincent-policy-commit-functions) section):\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { createVincentTool } from '@lit-protocol/vincent-tool-sdk';\nimport { z } from 'zod';\n\nconst vincentTool = createVincentTool({\n  // ... other policy definitions\n\n  executeSuccessSchema: z.object({\n    transferTransactionHash: z.string(),\n    spendTransactionHash: z.string().optional(),\n  }),\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\n### "
				},
				{
					"kind": "code",
					"text": "`executeFailSchema`"
				},
				{
					"kind": "text",
					"text": "\n\nThis Zod schema defines the structure of a failed "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " result. What's included in the returned object is up to you, but ideally it includes details about why the "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function failed.\n\nThe following schema returns error information to the Vincent Tool executor, including an error message, error code, and revert reason for failed transactions to assist with debugging:\n\n> **Note:** If any unhandled error occurs during execution of your tool's "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function, the Vincent Tool SDK will automatically return a "
				},
				{
					"kind": "code",
					"text": "`fail`"
				},
				{
					"kind": "text",
					"text": " result with the error message.\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { createVincentTool } from '@lit-protocol/vincent-tool-sdk';\nimport { z } from 'zod';\n\nconst vincentTool = createVincentTool({\n  // ... other policy definitions\n\n  executeFailSchema: z.object({\n    error: z.string(),\n    errorCode: z.string(),\n    revertReason: z.string(),\n    transferTransaction: z.object({\n      to: z.string(),\n      value: z.string(),\n      data: z.string(),\n      gasLimit: z.string(),\n      gasPrice: z.string(),\n      maxFeePerGas: z.string(),\n      maxPriorityFeePerGas: z.string(),\n      nonce: z.number(),\n      chainId: z.number(),\n      type: z.number(),\n    }),\n  }),\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\n## Executing Vincent Policy Commit Functions\n\nAfter your tool's "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function successfully completes, the last step of the function should be calling the "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " functions for any of your tool's supported Vincent Policies that have a "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " function. These "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " functions allow policies to update their internal state based on what actions your tool performed, and are usually critical to the functionality and security of the policies.\n\n> **WARNING** Your tool's "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function should always call the "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " functions for any of your tool's supported Vincent Policies that have a "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " function defined. Failing to do so could cause the Vincent Policies to operate incorrectly, failing to deny tool executions that exceed the Vincent App User's defined limits.\n\nVincent Policy commit functions are **optional** - not all policies will have them. They're typically used by policies that need to track cumulative data like spending amounts, execution counts, or other stateful information that depends on successful tool execution.\n\nAfter all the Vincent Policies that have been registered to be used with your tool for the specific Vincent App the tool is being executed for have been evaluated, the "
				},
				{
					"kind": "code",
					"text": "`policiesContext`"
				},
				{
					"kind": "text",
					"text": " property from the "
				},
				{
					"kind": "code",
					"text": "`toolContext`"
				},
				{
					"kind": "text",
					"text": " object will be updated to contain the policy evaluation results.\n\nThe "
				},
				{
					"kind": "code",
					"text": "`policiesContext`"
				},
				{
					"kind": "text",
					"text": " object contains a property called "
				},
				{
					"kind": "code",
					"text": "`allowedPolicies`"
				},
				{
					"kind": "text",
					"text": " that is an object where the keys are the package names of the evaluated Vincent policies, and the values are objects containing the "
				},
				{
					"kind": "code",
					"text": "`evalAllowResult`"
				},
				{
					"kind": "text",
					"text": " of the policy, and the policy's "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " function if one exists for the policy:\n\n> **Note:** The following interface isn't the actual interface used by the Vincent Tool SDK, it's just a simplified example of what the "
				},
				{
					"kind": "code",
					"text": "`policiesContext`"
				},
				{
					"kind": "text",
					"text": " object looks like for reference.\n>\n> The ["
				},
				{
					"kind": "code",
					"text": "`evalAllowResultSchema`"
				},
				{
					"kind": "text",
					"text": "]("
				},
				{
					"kind": "relative-link",
					"text": "./Creating-Policies.md#evalallowresultschema"
				},
				{
					"kind": "text",
					"text": ") and ["
				},
				{
					"kind": "code",
					"text": "`commitParamsSchema`"
				},
				{
					"kind": "text",
					"text": "]("
				},
				{
					"kind": "relative-link",
					"text": "./Creating-Policies.md#commitparamsschema"
				},
				{
					"kind": "text",
					"text": ") are Zod schemas specified by the Vincent Policy package.\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\ninterface PoliciesContext {\n  allowedPolicies: Record<\n    string,\n    {\n      result: evalAllowResultSchema;\n      commit: (\n        params: commitParamsSchema,\n      ) => Promise<commitAllowResultSchema | commitDenyResultSchema>;\n    }\n  >;\n}\n```"
				},
				{
					"kind": "text",
					"text": "\n\nFor our token transfer tool example, after successfully executing the transfer, we call the Vincent spending limit policy's "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " function to update the amount spent on behalf of the Vincent App User:\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { createVincentTool } from '@lit-protocol/vincent-tool-sdk';\n\nimport { createErc20TransferTransaction } from './my-tool-code';\n\nconst vincentTool = createVincentTool({\n  // ... other tool definitions\n\n  execute: async ({ toolParams }, toolContext) => {\n    const { tokenAddress, amountToSend, recipientAddress } = toolParams;\n\n    // previous code omitted for brevity\n\n    const transferTransactionHash = await transferTransaction.send();\n\n    const spendingLimitPolicyContext =\n      policiesContext.allowedPolicies['@lit-protocol/vincent-policy-spending-limit'];\n\n    let spendTransactionHash: string | undefined;\n\n    if (spendingLimitPolicyContext !== undefined) {\n      const commitResult = await spendingLimitPolicyContext.commit({\n        spentAmount: amountToSend,\n        tokenAddress,\n      });\n\n      if (commitResult.allow) {\n        spendTransactionHash = commitResult.result.spendTransactionHash;\n      } else {\n        return fail({\n          error:\n            commitResult.error ?? 'Unknown error occurred while committing spending limit policy',\n        });\n      }\n    }\n\n    return toolContext.succeed({\n      transferTransactionHash,\n      spendTransactionHash,\n    });\n  },\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\n# Wrapping Up\n\nThis guide has covered the basics of creating a Vincent Tool with supported Vincent Policies to be consumed by Vincent Apps. You've learned how to define supported Vincent Policies for your tool, how to define the tool's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " and "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " functions, how to execute Vincent Policy "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " functions, as well as how to define the schemas for the parameters required by the tool's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " and "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " functions.\n\nFor the token transfer tool example we've been building throughout this guide, the final tool definition would look like the following:\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport {\n  createVincentTool,\n  createVincentToolPolicy,\n  supportedPoliciesForTool,\n} from '@lit-protocol/vincent-tool-sdk';\nimport { bundledVincentPolicy } from '@lit-protocol/vincent-policy-spending-limit';\nimport { z } from 'zod';\n\nconst toolParamsSchema = z.object({\n  tokenAddress: z.string(),\n  amountToSend: z.number(),\n  recipientAddress: z.string(),\n});\n\nconst SpendingLimitPolicy = createVincentToolPolicy({\n  toolParamsSchema,\n  bundledVincentPolicy,\n  toolParameterMappings: {\n    tokenAddress: 'tokenAddress',\n    amountToSend: 'amount',\n  },\n});\n\nconst vincentTool = createVincentTool({\n  toolParamsSchema,\n\n  supportedPolicies: supportedPoliciesForTool([SpendingLimitPolicy]),\n\n  precheckSuccessSchema: z.object({\n    erc20TokenBalance: z.number(),\n    nativeTokenBalance: z.number(),\n    estimatedGas: z.number(),\n  }),\n  precheckFailSchema: z.object({\n    reason: z.string(),\n    currentBalance: z.number().optional(),\n    requiredAmount: z.number().optional(),\n  }),\n  precheck: async ({ toolParams }, toolContext) => {\n    const { tokenAddress, amountToSend, recipientAddress } = toolParams;\n\n    const erc20TokenBalance = await getErc20TokenBalance(\n      toolContext.delegation.delegatorPkpInfo.ethAddress,\n      tokenAddress,\n      amountToSend,\n    );\n    if (erc20TokenBalance < amountToSend) {\n      return toolContext.fail({\n        reason: 'Insufficient token balance',\n        currentBalance: erc20TokenBalance,\n        requiredAmount: amountToSend,\n      });\n    }\n\n    const transferTransaction = createErc20TransferTransaction(\n      tokenAddress,\n      recipientAddress,\n      amountToSend,\n    );\n\n    let estimatedGas;\n    try {\n      // Gas estimation might fail if transaction would revert\n      estimatedGas = await transferTransaction.estimateGas();\n    } catch (error) {\n      // Handle gas estimation failures (transaction would revert)\n      if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {\n        return toolContext.fail({\n          reason: 'Transaction reverted during gas estimation/transaction simulation',\n          errorCode: error.code,\n          revertReason: error.reason || 'Unknown revert reason',\n          transferTransaction,\n        });\n      }\n\n      // Let the Vincent Tool SDK handle the error\n      throw error;\n    }\n\n    const nativeTokenBalance = await getNativeTokenBalance(\n      toolContext.delegation.delegatorPkpInfo.ethAddress,\n      estimatedGas,\n    );\n\n    if (nativeTokenBalance < estimatedGas) {\n      return toolContext.fail({\n        reason: 'Insufficient native token balance',\n        currentBalance: nativeTokenBalance,\n        requiredAmount: estimatedGas,\n      });\n    }\n\n    return toolContext.succeed({\n      erc20TokenBalance,\n      nativeTokenBalance,\n      estimatedGas,\n    });\n  },\n\n  executeSuccessSchema: z.object({\n    transferTransactionHash: z.string(),\n    spendTransactionHash: z.string().optional(),\n  }),\n  executeFailSchema: z.object({\n    error: z.string(),\n    errorCode: z.string(),\n    revertReason: z.string(),\n    transferTransaction: z.object({\n      to: z.string(),\n      value: z.string(),\n      data: z.string(),\n      gasLimit: z.string(),\n      gasPrice: z.string(),\n      maxFeePerGas: z.string(),\n      maxPriorityFeePerGas: z.string(),\n      nonce: z.number(),\n      chainId: z.number(),\n      type: z.number(),\n    }),\n  }),\n  execute: async ({ toolParams }, toolContext) => {\n    const { tokenAddress, amountToSend, recipientAddress } = toolParams;\n\n    const transferTransaction = createErc20TransferTransaction(\n      tokenAddress,\n      recipientAddress,\n      amountToSend,\n    );\n\n    try {\n      // Estimate gas to catch potential revert reasons early\n      const estimatedGas = await transferTransaction.estimateGas();\n    } catch (error) {\n      // Handle different types of errors\n      if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {\n        return toolContext.fail({\n          error: 'Transaction reverted during gas estimation/transaction simulation',\n          errorCode: error.code,\n          revertReason: error.reason || 'Unknown revert reason',\n          transferTransaction,\n        });\n      }\n\n      // Let the Vincent Tool SDK handle the error\n      throw error;\n    }\n\n    const transferTransactionHash = await transferTransaction.send();\n\n    const spendingLimitPolicyContext =\n      policiesContext.allowedPolicies['@lit-protocol/vincent-policy-spending-limit'];\n\n    let spendTransactionHash: string | undefined;\n\n    if (spendingLimitPolicyContext !== undefined) {\n      const commitResult = await spendingLimitPolicyContext.commit({\n        spentAmount: amountToSend,\n        tokenAddress,\n      });\n\n      if (commitResult.allow) {\n        spendTransactionHash = commitResult.result.spendTransactionHash;\n      } else {\n        return fail({\n          error:\n            commitResult.error ?? 'Unknown error occurred while committing spending limit policy',\n        });\n      }\n    }\n\n    return toolContext.succeed({\n      transferTransactionHash,\n      spendTransactionHash,\n    });\n  },\n});\n```"
				}
			],
			"frontmatter": {
				"category": "Developers"
			}
		},
		{
			"id": 11,
			"name": "Creating Vincent Policies",
			"variant": "document",
			"kind": 8388608,
			"flags": {},
			"content": [
				{
					"kind": "text",
					"text": "# What is a Vincent Policy?\n\n<!-- TODO Link to Vincent Tool definition when it's available -->\n\nA Vincent Policy is a function built using [Lit Actions](https://developer.litprotocol.com/sdk/serverless-signing/overview) and is a programmable guardrail for Vincent Tool executions. These policies have user-configurable parameters and determine whether a Vincent App can execute specific Vincent Tools on behalf of a Vincent App User, ensuring that autonomous agents and Vincent Apps operate strictly within user-defined boundaries.\n\n## Key Capabilities of Vincent Policies\n\n- **Flexible Data Access:** Read and write both on and off-chain data to any blockchain network or HTTP-accessible API or database\n- **Stateful Policy Management:** Persist data across executions to track cumulative metrics and implement sophisticated rules like spending limits, rate limiting, and usage quotas\n- **Cryptographic Capabilities:** Utilize Lit Protocol's [Encryption and Access Control ](https://developer.litprotocol.com/sdk/access-control/intro) features for computing over private data within Lit's secure [Trusted Execution Environment (TEE)](https://en.wikipedia.org/wiki/Trusted_execution_environment)\n- **Type-Safe Development:** Strongly-typed Zod schemas ensure parameter validation and clear interfaces between Vincent Tools and Policies, and both utilize packages installed from NPM to extend functionality\n\n### Real-World Policy Examples\n\n**Financial Controls**\n\n- **Daily Spending Limits**: Track cumulative spending by storing transaction amounts on or off-chain and deny Vincent Tool execution when limits are exceeded\n- **Multi-Signature Requirements**: Require additional approvals for high-value transactions by integrating with on or off-chain approval systems\n- **Token Allowlists**: Restrict transactions to specific token types or verified contract addresses\n\n**Access Management**\n\n- **Membership Gates**: Verify ownership of on-chain assets (like NFTs), or off-chain data (like Discord roles) before allowing access to premium features\n- **Time-Based Restrictions**: Only allow Vincent Tool execution during specific hours, days, or based on cooldown periods\n\n**Usage Limits**\n\n- **Rate Limiting**: Track API usage frequency and implement cooldown periods between executions\n- **Compliance Monitoring**: Enforce regulatory requirements by checking transaction amounts against legal limits\n- **Geographic Restrictions**: Use IP geolocation APIs to restrict access based on user location\n\n**Risk Management**\n\n- **Transaction Pattern Analysis**: Monitor spending patterns and flag suspicious activity that deviates from normal behavior\n- **Circuit Breakers**: Automatically disable tools when unusual activity is detected or system-wide limits are reached\n- **Emergency Stops**: Implement admin-controlled emergency stops that can pause policy-governed operations\n\n# How a Vincent Policy Works\n\nA Vincent Policy consists of three main lifecycle methods executed in the following order:\n\n1. **Precheck**: Executed by the Vincent Tool's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function, your policy's precheck logic provides the Vincent Tool executor with a best-effort validation that your policy should permit the execution of the Vincent Tool given current policy conditions\n   - This function is executed locally by the Vincent Tool executor outside of the Lit Action environment\n2. **Evaluate**: Executed by the Vincent Tool's "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function, this is the validation logic that determines whether or not your policy permits the execution of the Vincent Tool based on given input parameters and current policy state\n   - This function is executed in the Lit Action environment\n3. **Commit**: An optional function used to commit results and update any state the policy depends on, executed after all the Vincent Policies registered by the Vincent User have been evaluated, and the Vincent Tool has executed successfully\n   - This function is executed in the Lit Action environment\n\n# Defining Your Vincent Policy\n\nVincent Policies are created by calling the "
				},
				{
					"kind": "code",
					"text": "`createVincentPolicy`"
				},
				{
					"kind": "text",
					"text": " function from the "
				},
				{
					"kind": "code",
					"text": "`@lit-protocol/vincent-tool-sdk`"
				},
				{
					"kind": "text",
					"text": " package. This function takes a single object as a parameter that defines your policy's lifecycle methods, parameter schemas, and return value schemas.\n\nThe basic structure of a Vincent Policy definition is as follows:\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nexport const vincentPolicy = createVincentPolicy({\n  packageName: '@my-npm-org/vincent-policy-my-name' as const,\n\n  toolParamsSchema,\n  userParamsSchema,\n\n  precheckAllowResultSchema,\n  precheckDenyResultSchema,\n  precheck: async ({ toolParams, userParams }, policyContext) => {},\n\n  evalAllowResultSchema,\n  evalDenyResultSchema,\n  evaluate: async ({ toolParams, userParams }, policyContext) => {},\n\n  commitParamsSchema,\n  commitAllowResultSchema,\n  commitDenyResultSchema,\n  commit: async (params, policyContext) => {},\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\n## "
				},
				{
					"kind": "code",
					"text": "`packageName`"
				},
				{
					"kind": "text",
					"text": "\n\nThe "
				},
				{
					"kind": "code",
					"text": "`packageName`"
				},
				{
					"kind": "text",
					"text": " serves as the unique identifier for your policy within the Vincent ecosystem. This **must exactly match** the NPM package name you publish your policy under, as Vincent Tool authors will use this identifier to install and integrate your policy into their tools.\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { createVincentPolicy } from '@lit-protocol/vincent-tool-sdk';\n\nconst vincentPolicy = createVincentPolicy({\n  packageName: '@my-npm-org/vincent-policy-my-name' as const,\n  // ... other policy definitions\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\n## The "
				},
				{
					"kind": "code",
					"text": "`policyContext`"
				},
				{
					"kind": "text",
					"text": " Argument\n\nThe "
				},
				{
					"kind": "code",
					"text": "`policyContext`"
				},
				{
					"kind": "text",
					"text": " argument is provided and managed by the Vincent Tool SDK. It's an object containing the following properties and is passed as an argument to your policy's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": ", "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": ", and "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " functions:\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\ninterface PolicyContext {\n  toolIpfsCid: string;\n  appId: number;\n  appVersion: number;\n  delegation: {\n    delegateeAddress: string;\n    delegatorPkpInfo: {\n      tokenId: string;\n      ethAddress: string;\n      publicKey: string;\n    };\n  };\n  allow: (allowResult) => void;\n  deny: (denyResult) => void;\n}\n```"
				},
				{
					"kind": "text",
					"text": "\n\nWhere:\n\n- "
				},
				{
					"kind": "code",
					"text": "`toolIpfsCid`"
				},
				{
					"kind": "text",
					"text": ": The IPFS CID of the Vincent Tool that is being executed\n- "
				},
				{
					"kind": "code",
					"text": "`appId`"
				},
				{
					"kind": "text",
					"text": ": The ID of the Vincent App the Vincent Tool is being executed for\n- "
				},
				{
					"kind": "code",
					"text": "`appVersion`"
				},
				{
					"kind": "text",
					"text": ": The version of the Vincent App the Vincent Tool is being executed for\n- "
				},
				{
					"kind": "code",
					"text": "`delegation`"
				},
				{
					"kind": "text",
					"text": ":\n  - "
				},
				{
					"kind": "code",
					"text": "`delegateeAddress`"
				},
				{
					"kind": "text",
					"text": ": The Ethereum address of the Vincent Tool executor\n  - "
				},
				{
					"kind": "code",
					"text": "`delegatorPkpInfo`"
				},
				{
					"kind": "text",
					"text": ":\n    <!-- TODO: Add link to Vincent Agent Wallet docs -->\n    - "
				},
				{
					"kind": "code",
					"text": "`tokenId`"
				},
				{
					"kind": "text",
					"text": ": The token ID of the Vincent App User's Vincent Agent Wallet\n    - "
				},
				{
					"kind": "code",
					"text": "`ethAddress`"
				},
				{
					"kind": "text",
					"text": ": The Ethereum address of the Vincent App User's Vincent Agent Wallet\n    - "
				},
				{
					"kind": "code",
					"text": "`publicKey`"
				},
				{
					"kind": "text",
					"text": ": The public key of the Vincent App User's Vincent Agent Wallet\n- "
				},
				{
					"kind": "code",
					"text": "`allow`"
				},
				{
					"kind": "text",
					"text": ": A helper method for returning an "
				},
				{
					"kind": "code",
					"text": "`allow`"
				},
				{
					"kind": "text",
					"text": " result from your policy's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": ", "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": ", and "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " functions\n- "
				},
				{
					"kind": "code",
					"text": "`deny`"
				},
				{
					"kind": "text",
					"text": ": A helper method for returning a "
				},
				{
					"kind": "code",
					"text": "`deny`"
				},
				{
					"kind": "text",
					"text": " result from your policy's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": ", "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": ", and "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " functions\n\n## Parameter Schemas\n\n### "
				},
				{
					"kind": "code",
					"text": "`toolParamsSchema`"
				},
				{
					"kind": "text",
					"text": "\n\nThis Zod schema defines the structure of parameters that Vincent Tools will pass to your policy. The Vincent Tool receives these parameters from the tool executor, and the Vincent Tool SDK handles passing these parameters to your policy as "
				},
				{
					"kind": "code",
					"text": "`toolParams`"
				},
				{
					"kind": "text",
					"text": ". These parameters should be the what your policy requires to make it's checks and validations.\n\nFor example, if you are building a spending limit policy, you might define the "
				},
				{
					"kind": "code",
					"text": "`toolParamsSchema`"
				},
				{
					"kind": "text",
					"text": " as follows:\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { createVincentPolicy } from '@lit-protocol/vincent-tool-sdk';\nimport { z } from 'zod';\n\nconst vincentPolicy = createVincentPolicy({\n  // ... other policy definitions\n\n  toolParamsSchema: z.object({\n    tokenAddress: z.string(),\n    amount: z.number(),\n  }),\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\nYour policy can then check whether spending "
				},
				{
					"kind": "code",
					"text": "`amount`"
				},
				{
					"kind": "text",
					"text": " of "
				},
				{
					"kind": "code",
					"text": "`tokenAddress`"
				},
				{
					"kind": "text",
					"text": " would exceed the Vincent App User's configured spending limit by querying its database of smart contract.\n\n### "
				},
				{
					"kind": "code",
					"text": "`userParamsSchema`"
				},
				{
					"kind": "text",
					"text": "\n\nThis Zod schema defines the structure of the on-chain parameters that Vincent App Users configure for your policy. These parameters are fetched from the Vincent smart contract during execution of a Vincent Policy's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " and "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": " functions. They are unique to each Vincent Tool and Vincent App union, and cannot be altered by the Vincent App or tool executor during execution.\n\nThese parameters are meant to be used to define the guardrails that Vincent App Users want to place on the Vincent Apps for executing Vincent Tools. For example, if you are building a spending limit policy, you might define the "
				},
				{
					"kind": "code",
					"text": "`userParamsSchema`"
				},
				{
					"kind": "text",
					"text": " as follows:\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { createVincentPolicy } from '@lit-protocol/vincent-tool-sdk';\nimport { z } from 'zod';\n\nconst vincentPolicy = createVincentPolicy({\n  // ... other policy definitions\n\n  userParamsSchema: z.object({\n    dailySpendingLimit: z.number(),\n    allowedTokens: z.array(z.string()).optional(),\n  }),\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\nThis would allow the Vincent App User to specify how much of a token they are allowing the Vincent App to spend on their behalf in a day, as well as the specific tokens that are allowed to be spent.\n\n## Precheck Function\n\nThe "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function is intended to be executed locally by the Vincent Tool executor to provide a best-effort check that the policy shouldn't fail when the policy's "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": " function is called.\n\nExecuting a Vincent Tool using the Lit network is an operation that cost both time and money, so your "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function should do whatever validation it can to ensure that the policy won't fail when the "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": " function is called.\n\nIn the case of our spending limit policy example, this would include a call to the spending limit database/smart contract to check if the amount of tokens the Vincent App is attempting to spend exceeds the spending limit the Vincent App User has set for the Vincent App:\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { createVincentPolicy } from '@lit-protocol/vincent-tool-sdk';\nimport { z } from 'zod';\n\nimport { checkSpendingLimit } from './my-policy-code';\n\nconst vincentPolicy = createVincentPolicy({\n  // ... other policy definitions\n\n  precheck: async ({ toolParams, userParams }, policyContext) => {\n    const { amount, tokenAddress } = toolParams;\n    const { dailySpendingLimit, allowedTokens } = userParams;\n\n    const isTokenAllowed = allowedTokens.includes(tokenAddress);\n    const { isSpendingLimitExceeded, currentDailySpending } = await checkSpendingLimit(\n      tokenAddress,\n      amount,\n      dailySpendingLimit,\n    );\n\n    if (!isTokenAllowed) {\n      return policyContext.deny({\n        reason: 'Token not allowed',\n        maxDailySpendingLimit: dailySpendingLimit,\n        currentDailySpending,\n        allowedTokens: allowedTokens,\n      });\n    }\n\n    if (isSpendingLimitExceeded) {\n      return policyContext.deny({\n        reason: 'Spending limit exceeded',\n        maxDailySpendingLimit: dailySpendingLimit,\n        currentDailySpending,\n        allowedTokens: allowedTokens,\n      });\n    }\n\n    return policyContext.allow({\n      maxDailySpendingLimit: dailySpendingLimit,\n      currentDailySpending,\n      allowedTokens: allowedTokens,\n    });\n  },\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\nTwo arguments are passed to your policy's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function by the Vincent Tool SDK. The first is an object containing the "
				},
				{
					"kind": "code",
					"text": "`toolParams`"
				},
				{
					"kind": "text",
					"text": " and "
				},
				{
					"kind": "code",
					"text": "`userParams`"
				},
				{
					"kind": "text",
					"text": " that adhere to the "
				},
				{
					"kind": "code",
					"text": "`toolParamsSchema`"
				},
				{
					"kind": "text",
					"text": " and "
				},
				{
					"kind": "code",
					"text": "`userParamsSchema`"
				},
				{
					"kind": "text",
					"text": " you have defined for your policy. The second is the ["
				},
				{
					"kind": "code",
					"text": "`policyContext`"
				},
				{
					"kind": "text",
					"text": "](#the-policycontext-argument) managed by the Vincent Tool SDK that contains helper methods for returning "
				},
				{
					"kind": "code",
					"text": "`allow`"
				},
				{
					"kind": "text",
					"text": " and "
				},
				{
					"kind": "code",
					"text": "`deny`"
				},
				{
					"kind": "text",
					"text": " results, as well as some metadata about the Vincent App that the policy is being executed for.\n\n### "
				},
				{
					"kind": "code",
					"text": "`precheckAllowResultSchema`"
				},
				{
					"kind": "text",
					"text": "\n\nThis Zod schema defines the structure of successful "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " results. What's included in the returned object is up to you, but ideally it includes details about why the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " passed.\n\nThe following schema returns useful information to the Vincent Tool executor about the current policy state for the Vincent App User and Vincent App combo:\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { createVincentPolicy } from '@lit-protocol/vincent-tool-sdk';\nimport { z } from 'zod';\n\nconst vincentPolicy = createVincentPolicy({\n  // ... other policy definitions\n\n  precheckAllowResultSchema: z.object({\n    maxDailySpendingLimit: z.number(),\n    currentDailySpending: z.number(),\n    allowedTokens: z.array(z.string()),\n  }),\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\nSpecifying "
				},
				{
					"kind": "code",
					"text": "`maxDailySpendingLimit`"
				},
				{
					"kind": "text",
					"text": " allows the Vincent Tool executor to adapt to the Vincent App User modifying their spending limit for the Vincent App. "
				},
				{
					"kind": "code",
					"text": "`currentDailySpending`"
				},
				{
					"kind": "text",
					"text": " is useful to know so that the Vincent App can understand how much of the spending limit has been used, and "
				},
				{
					"kind": "code",
					"text": "`allowedTokens`"
				},
				{
					"kind": "text",
					"text": " allows the Vincent App to avoid trying to spend tokens that will cause the policy to fail.\n\n### "
				},
				{
					"kind": "code",
					"text": "`precheckDenyResultSchema`"
				},
				{
					"kind": "text",
					"text": "\n\nThis Zod schema defines the structure of a failed "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " result. What's included in the returned object is up to you, but ideally it includes details about why the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " failed.\n\nThe following schema returns additional information to the Vincent Tool executor that would allow them to adapt their execution request so that the policy's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " validation checks don't fail:\n\n> **Note:** If any unhandled error occurs during execution of your policy's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function, the Vincent Tool SDK will automatically return a "
				},
				{
					"kind": "code",
					"text": "`deny`"
				},
				{
					"kind": "text",
					"text": " result with the error message.\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { createVincentPolicy } from '@lit-protocol/vincent-tool-sdk';\nimport { z } from 'zod';\n\nconst vincentPolicy = createVincentPolicy({\n  // ... other policy definitions\n\n  precheckDenyResultSchema: z.object({\n    reason: z.string(),\n    maxDailySpendingLimit: z.number(),\n    currentDailySpending: z.number(),\n    allowedTokens: z.array(z.string()),\n  }),\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\nFor the above schema, the "
				},
				{
					"kind": "code",
					"text": "`reason`"
				},
				{
					"kind": "text",
					"text": " string allows the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function to return a specific error message stating something like "
				},
				{
					"kind": "code",
					"text": "`\"Attempted buy amount exceeds daily limit\"`"
				},
				{
					"kind": "text",
					"text": " or "
				},
				{
					"kind": "code",
					"text": "`\"Token not on allow list\"`"
				},
				{
					"kind": "text",
					"text": ".\n\n## Evaluate Function\n\nThe "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": " function is the validation logic executed in the beginning of the Vincent Tool's "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function, used to inform the tool whether it can execute the tool logic.\n\nIt's may be similar in logic to the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function, but the "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": " function has the ability to deny Vincent Tool execution if your policy returns the "
				},
				{
					"kind": "code",
					"text": "`deny`"
				},
				{
					"kind": "text",
					"text": " result. Additionally, while the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function is executed locally by the Vincent Tool executor, the "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": " function is executed in the Lit Action environment during the execution of the tool's "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " function, and has access to the full Lit Action environment (for more information on what's available to you within the Lit Action environment see the Lit Protocol [Lit Action](https://developer.litprotocol.com/sdk/serverless-signing/overview) docs).\n\nIn the case of our spending limit policy example, the "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": " function is going to be identical to the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function:\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { createVincentPolicy } from '@lit-protocol/vincent-tool-sdk';\nimport { z } from 'zod';\n\nimport { checkSpendingLimit } from './my-policy-code';\n\nconst vincentPolicy = createVincentPolicy({\n  // ... other policy definitions\n\n  evaluate: async ({ toolParams, userParams }, policyContext) => {\n    const { amount, tokenAddress } = toolParams;\n    const { dailySpendingLimit, allowedTokens } = userParams;\n\n    const isTokenAllowed = allowedTokens.includes(tokenAddress);\n    const { isSpendingLimitExceeded, currentDailySpending } = await checkSpendingLimit(\n      tokenAddress,\n      amount,\n      dailySpendingLimit,\n    );\n\n    if (!isTokenAllowed) {\n      return policyContext.deny({\n        reason: 'Token not allowed',\n        maxDailySpendingLimit: dailySpendingLimit,\n        currentDailySpending,\n        allowedTokens: allowedTokens,\n      });\n    }\n\n    if (isSpendingLimitExceeded) {\n      return policyContext.deny({\n        reason: 'Spending limit exceeded',\n        maxDailySpendingLimit: dailySpendingLimit,\n        currentDailySpending,\n        allowedTokens: allowedTokens,\n      });\n    }\n\n    return policyContext.allow({\n      maxDailySpendingLimit: dailySpendingLimit,\n      currentDailySpending,\n      allowedTokens: allowedTokens,\n    });\n  },\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\nTwo arguments are passed to your policy's "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": " function by the Vincent Tool SDK. The first is an object containing the "
				},
				{
					"kind": "code",
					"text": "`toolParams`"
				},
				{
					"kind": "text",
					"text": " and "
				},
				{
					"kind": "code",
					"text": "`userParams`"
				},
				{
					"kind": "text",
					"text": " that adhere to the "
				},
				{
					"kind": "code",
					"text": "`toolParamsSchema`"
				},
				{
					"kind": "text",
					"text": " and "
				},
				{
					"kind": "code",
					"text": "`userParamsSchema`"
				},
				{
					"kind": "text",
					"text": " you have defined for your policy, and the second is the same ["
				},
				{
					"kind": "code",
					"text": "`policyContext`"
				},
				{
					"kind": "text",
					"text": "](#the-policycontext-argument) passed to the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " function.\n\n### "
				},
				{
					"kind": "code",
					"text": "`evalAllowResultSchema`"
				},
				{
					"kind": "text",
					"text": "\n\nThis Zod schema defines the structure of a successful "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": " result. What's included in the returned object is up to you, but ideally it includes details about why the "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": " function is allowing the Vincent Tool execution.\n\nThe following schema returns useful information to the Vincent Tool executor about the current policy state for the Vincent App User and Vincent App combo:\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { createVincentPolicy } from '@lit-protocol/vincent-tool-sdk';\nimport { z } from 'zod';\n\nconst vincentPolicy = createVincentPolicy({\n  // ... other policy definitions\n\n  evalAllowResultSchema: z.object({\n    maxDailySpendingLimit: z.number(),\n    currentDailySpending: z.number(),\n    allowedTokens: z.array(z.string()),\n  }),\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\n### "
				},
				{
					"kind": "code",
					"text": "`evalDenyResultSchema`"
				},
				{
					"kind": "text",
					"text": "\n\nThis Zod schema defines the structure of a denied "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": " result. What's included in the returned object is up to you, but ideally it includes details about why the "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": " function is denying the Vincent Tool execution.\n\nThe following schema returns additional information to the Vincent Tool executor that would allow the Vincent Tool executor to adapt their execution request so that the policy's "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": " validation checks don't fail:\n\n> **Note:** If any unhandled error occurs during execution of your policy's "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": " function, the Vincent Tool SDK will automatically return a "
				},
				{
					"kind": "code",
					"text": "`deny`"
				},
				{
					"kind": "text",
					"text": " result with the error message.\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { createVincentPolicy } from '@lit-protocol/vincent-tool-sdk';\nimport { z } from 'zod';\n\nconst vincentPolicy = createVincentPolicy({\n  // ... other policy definitions\n\n  evalDenyResultSchema: z.object({\n    reason: z.string(),\n    maxDailySpendingLimit: z.number(),\n    currentDailySpending: z.number(),\n    allowedTokens: z.array(z.string()),\n  }),\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\n## Commit Function\n\nThe "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " function is called by the Vincent Tool's "
				},
				{
					"kind": "code",
					"text": "`execute`"
				},
				{
					"kind": "text",
					"text": " method after all the Vincent Policies registered by the Vincent User have been evaluated and returned "
				},
				{
					"kind": "code",
					"text": "`allow`"
				},
				{
					"kind": "text",
					"text": " results, and the Vincent Tool's execution logic has been successfully executed. This function is **optional**, and is only required if you need to update any state that the policy depends on, after the Vincent Tool executes.\n\nFor the spending limit policy example, the "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " function would be used to update the spending limit database/smart contract with the amount of tokens the Vincent App has spent on behalf of the Vincent App User:\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { createVincentPolicy } from '@lit-protocol/vincent-tool-sdk';\nimport { z } from 'zod';\n\nimport { updateSpentAmount } from './my-policy-code';\n\nconst vincentPolicy = createVincentPolicy({\n  // ... other policy definitions\n\n  commit: async (params, policyContext) => {\n    const { spentAmount, tokenAddress } = params;\n\n    try {\n      const { updatedDailySpending, remainingDailyLimit } = await updateSpentAmount({\n        vincentAppId: policyContext.appId,\n        spenderAddress: policyContext.delegation.delegatorPkpInfo.ethAddress,\n        spentAmount,\n        spentTokenAddress: tokenAddress,\n      });\n\n      return policyContext.allow({\n        vincentAppId: policyContext.appId,\n        spenderAddress: policyContext.delegation.delegatorPkpInfo.ethAddress,\n        updatedDailySpending,\n        remainingDailyLimit,\n      });\n    } catch (error) {\n      return policyContext.deny({\n        reason: 'Failed to update spending limit',\n        vincentAppId: policyContext.appId,\n        spenderAddress: policyContext.delegation.delegatorPkpInfo.ethAddress,\n        spentAmount,\n        spentTokenAddress: tokenAddress,\n      });\n    }\n  },\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\nTwo arguments are passed to your policy's "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " function by the Vincent Tool SDK. The first is an object adhering to the "
				},
				{
					"kind": "code",
					"text": "`commitParamsSchema`"
				},
				{
					"kind": "text",
					"text": " you have defined for your policy, and the second is the same ["
				},
				{
					"kind": "code",
					"text": "`policyContext`"
				},
				{
					"kind": "text",
					"text": "](#the-policycontext-argument) passed to the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " and "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": " functions.\n\nNotice that unlike the "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": " and "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": " functions, the "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " functions does **not** receive the "
				},
				{
					"kind": "code",
					"text": "`toolParams`"
				},
				{
					"kind": "text",
					"text": " and "
				},
				{
					"kind": "code",
					"text": "`userParams`"
				},
				{
					"kind": "text",
					"text": " arguments. If you need access to any of the variables specified in those objects, make sure to include them in the "
				},
				{
					"kind": "code",
					"text": "`commitParamsSchema`"
				},
				{
					"kind": "text",
					"text": " you have defined for your policy.\n\n### "
				},
				{
					"kind": "code",
					"text": "`commitParamsSchema`"
				},
				{
					"kind": "text",
					"text": "\n\nThe "
				},
				{
					"kind": "code",
					"text": "`params`"
				},
				{
					"kind": "text",
					"text": " argument provided to your "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " function will follow the structure of the "
				},
				{
					"kind": "code",
					"text": "`commitParamsSchema`"
				},
				{
					"kind": "text",
					"text": " you will have defined for your policy. What's provided in the "
				},
				{
					"kind": "code",
					"text": "`params`"
				},
				{
					"kind": "text",
					"text": " object is up to you, but it should include the specific parameters that your policy needs to update the state your policy depends on for it's validation checks.\n\nFor the spending limit policy example, the following parameters are required in order to update the amount of tokens that have been spent by the Vincent App on behalf of the Vincent App User:\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { createVincentPolicy } from '@lit-protocol/vincent-tool-sdk';\nimport { z } from 'zod';\n\nimport { updateSpentAmount } from './my-policy-code';\n\nconst vincentPolicy = createVincentPolicy({\n  // ... other policy definitions\n\n  commitParamsSchema: z.object({\n    spentAmount: z.number(),\n    tokenAddress: z.string(),\n  }),\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\n### "
				},
				{
					"kind": "code",
					"text": "`commitAllowResultSchema`"
				},
				{
					"kind": "text",
					"text": "\n\nThis Zod schema defines the structure of an "
				},
				{
					"kind": "code",
					"text": "`allow`"
				},
				{
					"kind": "text",
					"text": " result from your policy's "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " function. What's included in the returned object is up to you, but ideally it includes details about what state was successfully updated by your policy's "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " function.\n\nFor the spending limit policy example, the following schema returns useful information about the state updates that were committed:\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { createVincentPolicy } from '@lit-protocol/vincent-tool-sdk';\nimport { z } from 'zod';\n\nconst vincentPolicy = createVincentPolicy({\n  // ... other policy definitions\n\n  commitAllowResultSchema: z.object({\n    vincentAppId: z.number(),\n    spenderAddress: z.string(),\n    updatedDailySpending: z.number(),\n    remainingDailyLimit: z.number(),\n  }),\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\nThese details provide transparency about what was updated during the commit phase, allowing the Vincent Tool executor to understand the current state after the successful execution of the Vincent Tool.\n\n### "
				},
				{
					"kind": "code",
					"text": "`commitDenyResultSchema`"
				},
				{
					"kind": "text",
					"text": "\n\nThis Zod schema defines the structure of a failed "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " result. What's included in the returned object is up to you, but ideally it includes details about why the "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " function failed to update the policy's state.\n\nThe following schema returns information that would help the Vincent Tool executor understand why the "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " function failed to update the policy's state, as well as the data the "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " function was attempting to update it's state with:\n\n> **Note:** If any unhandled error occurs during execution of your policy's "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " function, the Vincent Tool SDK will automatically return a "
				},
				{
					"kind": "code",
					"text": "`deny`"
				},
				{
					"kind": "text",
					"text": " result with the error message.\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { createVincentPolicy } from '@lit-protocol/vincent-tool-sdk';\nimport { z } from 'zod';\n\nconst vincentPolicy = createVincentPolicy({\n  // ... other policy definitions\n\n  commitDenyResultSchema: z.object({\n    reason: z.string(),\n    vincentAppId: z.number(),\n    spenderAddress: z.string(),\n    spentAmount: z.number(),\n    spentTokenAddress: z.string(),\n  }),\n});\n```"
				},
				{
					"kind": "text",
					"text": "\n\n# Wrapping Up\n\nThis guide has covered the basics of creating a Vincent Policy to be consumed by Vincent Tools. You've learned how to define the policy's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": ", "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": ", and "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " functions, as well as the schemas for the parameters required by the policy's "
				},
				{
					"kind": "code",
					"text": "`precheck`"
				},
				{
					"kind": "text",
					"text": ", "
				},
				{
					"kind": "code",
					"text": "`evaluate`"
				},
				{
					"kind": "text",
					"text": ", and "
				},
				{
					"kind": "code",
					"text": "`commit`"
				},
				{
					"kind": "text",
					"text": " functions.\n\nFor the spending limit policy example we've been building throughout this guide, the final policy definition would look like the following:\n\n"
				},
				{
					"kind": "code",
					"text": "```typescript\nimport { createVincentPolicy } from '@lit-protocol/vincent-tool-sdk';\nimport { z } from 'zod';\n\nconst vincentPolicy = createVincentPolicy({\n  packageName: '@my-npm-org/vincent-policy-my-name' as const,\n\n  toolParamsSchema: z.object({\n    tokenAddress: z.string(),\n    amount: z.number(),\n  }),\n  userParamsSchema: z.object({\n    dailySpendingLimit: z.number(),\n    allowedTokens: z.array(z.string()).optional(),\n  }),\n\n  precheckAllowResultSchema: z.object({\n    maxDailySpendingLimit: z.number(),\n    currentDailySpending: z.number(),\n    allowedTokens: z.array(z.string()),\n  }),\n  precheckDenyResultSchema: z.object({\n    reason: z.string(),\n    maxDailySpendingLimit: z.number(),\n    currentDailySpending: z.number(),\n    allowedTokens: z.array(z.string()),\n  }),\n  precheck: async ({ toolParams, userParams }, policyContext) => {\n    const { amount, tokenAddress } = toolParams;\n    const { dailySpendingLimit, allowedTokens } = userParams;\n\n    const isTokenAllowed = allowedTokens.includes(tokenAddress);\n    const { isSpendingLimitExceeded, currentDailySpending } = await checkSpendingLimit(\n      tokenAddress,\n      amount,\n      dailySpendingLimit,\n    );\n\n    if (!isTokenAllowed) {\n      return policyContext.deny({\n        reason: 'Token not allowed',\n        maxDailySpendingLimit: dailySpendingLimit,\n        currentDailySpending,\n        allowedTokens: allowedTokens,\n      });\n    }\n\n    if (isSpendingLimitExceeded) {\n      return policyContext.deny({\n        reason: 'Spending limit exceeded',\n        maxDailySpendingLimit: dailySpendingLimit,\n        currentDailySpending,\n        allowedTokens: allowedTokens,\n      });\n    }\n\n    return policyContext.allow({\n      maxDailySpendingLimit: dailySpendingLimit,\n      currentDailySpending,\n      allowedTokens: allowedTokens,\n    });\n  },\n\n  evalAllowResultSchema: z.object({\n    maxDailySpendingLimit: z.number(),\n    currentDailySpending: z.number(),\n    allowedTokens: z.array(z.string()),\n  }),\n  evalDenyResultSchema: z.object({\n    reason: z.string(),\n    maxDailySpendingLimit: z.number(),\n    currentDailySpending: z.number(),\n    allowedTokens: z.array(z.string()),\n  }),\n  evaluate: async ({ toolParams, userParams }, policyContext) => {\n    const { amount, tokenAddress } = toolParams;\n    const { dailySpendingLimit, allowedTokens } = userParams;\n\n    const isTokenAllowed = allowedTokens.includes(tokenAddress);\n    const { isSpendingLimitExceeded, currentDailySpending } = await checkSpendingLimit(\n      tokenAddress,\n      amount,\n      dailySpendingLimit,\n    );\n\n    if (!isTokenAllowed) {\n      return policyContext.deny({\n        reason: 'Token not allowed',\n        maxDailySpendingLimit: dailySpendingLimit,\n        currentDailySpending,\n        allowedTokens: allowedTokens,\n      });\n    }\n\n    if (isSpendingLimitExceeded) {\n      return policyContext.deny({\n        reason: 'Spending limit exceeded',\n        maxDailySpendingLimit: dailySpendingLimit,\n        currentDailySpending,\n        allowedTokens: allowedTokens,\n      });\n    }\n\n    return policyContext.allow({\n      maxDailySpendingLimit: dailySpendingLimit,\n      currentDailySpending,\n      allowedTokens: allowedTokens,\n    });\n  },\n\n  commitParamsSchema: z.object({\n    spentAmount: z.number(),\n    tokenAddress: z.string(),\n  }),\n  commitAllowResultSchema: z.object({\n    updatedDailySpending: z.number(),\n    remainingDailyLimit: z.number(),\n  }),\n  commitDenyResultSchema: z.object({\n    reason: z.string(),\n    vincentAppId: z.number(),\n    spenderAddress: z.string(),\n    spentAmount: z.number(),\n    spentTokenAddress: z.string(),\n  }),\n  commit: async (params, policyContext) => {\n    const { spentAmount, tokenAddress } = params;\n\n    try {\n      const { updatedDailySpending, remainingDailyLimit } = await updateSpentAmount({\n        vincentAppId: policyContext.appId,\n        spenderAddress: policyContext.delegation.delegatorPkpInfo.ethAddress,\n        spentAmount,\n        spentTokenAddress: tokenAddress,\n      });\n\n      return policyContext.allow({\n        updatedDailySpending,\n        remainingDailyLimit,\n      });\n    } catch (error) {\n      return policyContext.deny({\n        reason: 'Failed to update spending limit',\n        vincentAppId: policyContext.appId,\n        spenderAddress: policyContext.delegation.delegatorPkpInfo.ethAddress,\n        spentAmount,\n        spentTokenAddress: tokenAddress,\n      });\n    }\n  },\n});\n```"
				}
			],
			"frontmatter": {
				"category": "Developers"
			}
		},
		{
			"id": 12,
			"name": "Onboarding",
			"variant": "document",
			"kind": 8388608,
			"flags": {},
			"content": [
				{
					"kind": "text",
					"text": "# Onboarding\n\nEach time you visit an app on Vincent, you’ll be directed to that app’s dedicated consent page. This is where you will configure and manage your app-specific delegations, permitting it to use your assets and data according to the guidelines you set. Follow the steps below to begin your journey.\n\n## 1. Create an Agent Wallet\n\nThe first time you visit an app powered by Vincent, you’ll be prompted to create your Agent Wallet using a credential of your choice. Currently, email, phone number, and Passkey methods are supported. This credential is used to control your Agent Wallet which is securely managed by Lit Protocol’s [decentralized key management network](https://developer.litprotocol.com/resources/how-it-works). By default, the same Agent Wallet will be used across all Vincent applications.\n\n![User Login]("
				},
				{
					"kind": "relative-link",
					"text": "./images/login.png",
					"target": 18
				},
				{
					"kind": "text",
					"text": ")\n\n## 2. Review Permissions & Delegate\n\nAfter you login you'll be required to review the permissions requested by the app on the Consent Page. On this page you can see the following details about the app:\n\n- **App:** The name and description of the app you're visiting.\n- **Account Address:** The EOA wallet address associated with the App creator.\n- **App Version:** The version of the app you're visiting. If the app publishes a new version you'll be prompted to update it.\n- **Tools:** Tools are used to execute the operations that you permit a given app to perform on your _behalf_ using your Agent Wallet. All Tools are represented by [Lit Actions](https://developer.litprotocol.com/sdk/serverless-signing/overview). After you delegate your Agent Wallet to a given Tool, the application owner can no longer change the Tool's behavior, making the delegation system immutable. As the owner of your Agent Wallet, you always have the ability to revoke a Tool that you previously permitted.\n- **Policies:** Policies are the guardrails you set for permitted tools, dictating the conditions that they operate under. An example is a daily spend limit, or requiring MFA for swaps exceeding a specific dollar amount. When you define a Policy, it must be met before a given Tool can be executed. Just like Tools, Policies are also codified as Lit Actions.\n\n![Consent Page]("
				},
				{
					"kind": "relative-link",
					"text": "./images/consent-page.png",
					"target": 19
				},
				{
					"kind": "text",
					"text": ")\n\n## 3. Update App Version\n\nOnce you've approved an App and it publishes a new version, you'll be prompted to update to the latest version when you visit the App's Consent Page again. Note, it's not mandatory to update to the latest version unless the App disables an older version.\n\n![Update App Version]("
				},
				{
					"kind": "relative-link",
					"text": "./images/consent-update.png",
					"target": 20
				},
				{
					"kind": "text",
					"text": ")\n\n## 4. Redirect to the App\n\nAfter you've logged in via the Consent Page you'll be redirected to the App page based on the "
				},
				{
					"kind": "code",
					"text": "`redirectUri`"
				},
				{
					"kind": "text",
					"text": " specified in the URLSearchParams: "
				},
				{
					"kind": "code",
					"text": "`https://dashboard.heyvincent.ai/appId/160/consent?redirectUri=http://localhost:3000`"
				}
			],
			"frontmatter": {
				"category": "Users"
			}
		},
		{
			"id": 13,
			"name": "Contact Us",
			"variant": "document",
			"kind": 8388608,
			"flags": {},
			"content": [
				{
					"kind": "text",
					"text": "# Contact Us\n\nIf you have any issues with the Vincent SDK, general questions about Vincent, or specific feature requests, please post them on the official [Vincent GitHub Repo](https://github.com/LIT-Protocol/Vincent/issues).\n\n## Join the Community\n\nJoin the Vincent developer community on [Telegram](https://t.me/c/2038294753/3289) and [Discord](https://discord.com/invite/nm9aBG8z9w) to stay up to date on the latest developments, troubleshoot errors, get technical support, and engage with fellow builders.\n\nHave an idea for a project or currently building? We'd love to hear from you! Follow Lit on [X](https://x.com/LitProtocol) and engage with us."
				}
			],
			"frontmatter": {
				"category": "Contact"
			}
		}
	],
	"groups": [
		{
			"title": "Documents",
			"children": [
				1,
				2,
				3,
				4,
				5,
				6,
				7,
				8,
				9,
				10,
				11,
				12,
				13
			]
		}
	],
	"categories": [
		{
			"title": "Intro",
			"children": [
				1
			]
		},
		{
			"title": "Developers",
			"children": [
				3,
				4,
				5,
				6,
				7,
				8,
				9,
				10,
				11
			]
		},
		{
			"title": "Users",
			"children": [
				2,
				12
			]
		},
		{
			"title": "Contact",
			"children": [
				13
			]
		}
	],
	"packageName": "@lit-protocol/vincent-source",
	"readme": [
		{
			"kind": "text",
			"text": "# Start Here\n\nVincent is an open-source framework powered by [Lit Protocol](https://litprotocol.com/) that empowers developers to create automated, user-controlled AI agents. With Vincent, you can build agents that automate the execution of operations across crypto networks, traditional finance (TradFi), and e-commerce platforms—all while ensuring users retain full control over their assets and data. Powered by Lit’s decentralized [key management network](https://developer.litprotocol.com/resources/how-it-works) and smart contracts, Vincent is your gateway to the future of the automated, User-Owned Web.\n\n[Demo](https://demo.heyvincent.ai/) |\n[Source Code](https://github.com/LIT-Protocol/vincent-dca/tree/main)\n\n## Why Vincent?\n\nVincent optimizes for security, interoperability, and user-control to redefine how agents interact across Web3 and beyond:\n\n- **Decentralized Key Management**: Vincent leverages Lit Protocol's [Programmable Key Pairs](https://developer.litprotocol.com/user-wallets/pkps/overview) (PKPs) to securely manage agent identities without exposing private keys.\n\n- **Verifiable, Fine-Grained Policies**: Users have full control over the policies they set and can revoke them at any time. Policies are fine-grained to specific operations and verifiable on-chain.\n\n- **Cross-Platform Automation**: With Vincent, agents can operate seamlessly across any blockchain or off-chain platform. Build agent-powered apps and tools for DeFi, TradFi, E-Commerce, and more.\n\n- **Agent Marketplace**: Vincent will eventually serve as a marketplace for Vincent-powered apps and tools, enabling them to be discovered and interacted with by end users.\n\n- **Open Source**: Fork, customize, and contribute to the [Vincent codebase](https://github.com/LIT-Protocol/Vincent) to shape the future of the agent-driven and user-controlled Web.\n\n## Get Started in Minutes\n\nIf you're a developer looking to deploy your first Vincent-enabled application or tool, head on over to the [quick start]("
		},
		{
			"kind": "relative-link",
			"text": "../docs/Developers/Quick-Start.md"
		},
		{
			"kind": "text",
			"text": ").\n\nIf you're looking to give Vincent a try as a user, check out the official demo showcasing [automated dollar-cost-averaging](https://demo.heyvincent.ai/).\n\n## Support\n\nIf you have any issues with the Vincent SDK, general questions about Vincent, or specific feature requests, please post them on the official [Vincent GitHub Repo](https://github.com/LIT-Protocol/Vincent/issues).\n\n## Join the Community\n\nWe want to hear from you! Join the [official Lit Protocol builders channel](https://t.me/c/2038294753/1) on Telegram to join the conversation and share your feedback.\n\nTo stay up to date on the latest updates, follow Lit on [X](https://x.com/LitProtocol)."
		}
	],
	"symbolIdMap": {},
	"files": {
		"entries": {
			"1": "docs/src/Why-Vincent.md",
			"2": "docs/src/Concepts.md",
			"3": "docs/src/Developers/App-Agent-Developers/Getting-Started.md",
			"4": "docs/src/Developers/Tool-Developers/Getting-Started.md",
			"5": "docs/src/Developers/Policy-Developers/Getting-Started.md",
			"6": "docs/src/Developers/Getting-Started.md",
			"7": "docs/src/Developers/App-Agent-Developers/Creating-Apps.md",
			"8": "docs/src/Developers/App-Agent-Developers/Auth-Users.md",
			"9": "docs/src/Developers/App-Agent-Developers/Executing-Tools.md",
			"10": "docs/src/Developers/Tool-Developers/Creating-Tools.md",
			"11": "docs/src/Developers/Policy-Developers/Creating-Policies.md",
			"12": "docs/src/Developers/images/connect-app-management-wallet.png",
			"13": "docs/src/Developers/images/create-new-app.png",
			"14": "docs/src/Developers/images/consent-ui.png",
			"15": "docs/src/Developers/images/vincent-app-manage-delegatees.png",
			"16": "docs/src/Developers/images/vincent-app-generate-app-url.png",
			"17": "docs/src/Developers/images/vincent-app-dashboard.png",
			"18": "docs/src/Users/images/login.png",
			"19": "docs/src/Users/images/consent-page.png",
			"20": "docs/src/Users/images/consent-update.png",
			"21": "docs/src/Users/Onboarding.md",
			"22": "docs/src/Contact-Us.md"
		},
		"reflections": {
			"1": 1,
			"2": 2,
			"3": 4,
			"4": 5,
			"5": 6,
			"6": 3,
			"7": 7,
			"8": 8,
			"9": 9,
			"10": 10,
			"11": 11,
			"21": 12,
			"22": 13
		}
	}
}
