const fs = require('fs');
const path = require('path');

const esbuild = require('esbuild');
const { polyfillNode } = require('esbuild-plugin-polyfill-node');
const Hash = require('ipfs-only-hash');

/**
 * Creates a plugin to alias fetch implementations to a shim
 * @param {string} shimPath - Path to the fetch shim
 * @returns {object} esbuild plugin
 */
function aliasFetch(shimPath) {
  return {
    name: 'alias-fetch',
    setup(build) {
      build.onResolve({ filter: /^node-fetch$/ }, () => ({ path: shimPath }));
      build.onResolve({ filter: /^cross-fetch(\/.*)?$/ }, () => ({ path: shimPath }));
    },
  };
}

/**
 * Ensures a directory exists
 * @param {string} filePath - Path to the file
 */
const ensureDirectoryExistence = (filePath) => {
  const dirname = path.dirname(filePath);
  if (!fs.existsSync(dirname)) {
    fs.mkdirSync(dirname, { recursive: true });
  }
};

/**
 * Gets the bundled Vincent ability code
 * @param {string} ipfsCid - The IPFS CID of the ability
 * @param {string} vincentAbilityPath - Path to the vincent-ability
 * @returns {string} The bundled ability code
 */
function getBundledVincentAbilityCode(ipfsCid, vincentAbilityPath) {
  return `/**
* DO NOT EDIT THIS FILE. IT IS GENERATED ON BUILD.
*/

import { asBundledVincentAbility } from '@lit-protocol/vincent-ability-sdk';
import { vincentAbility } from '${vincentAbilityPath}';
import metadata from './vincent-ability-metadata.json';


export const bundledVincentAbility = asBundledVincentAbility(vincentAbility, metadata.ipfsCid);
`;
}

/**
 * Gets the bundled Vincent policy code
 * @param {string} ipfsCid - The IPFS CID of the policy
 * @param {string} vincentPolicyPath - Path to the vincent-policy
 * @returns {string} The bundled policy code
 */
function getBundledVincentPolicyCode(ipfsCid, vincentPolicyPath) {
  return `/**
* DO NOT EDIT THIS FILE. IT IS GENERATED ON BUILD.
*/

import { asBundledVincentPolicy } from '@lit-protocol/vincent-ability-sdk';
import { vincentPolicy } from '${vincentPolicyPath}';
import metadata from './vincent-policy-metadata.json';

if(!metadata.ipfsCid) {
  throw new Error('ipfsCid is not defined in metadata JSON file');
}

export const bundledVincentPolicy = asBundledVincentPolicy(vincentPolicy, metadata.ipfsCid);
`;
}

/**
 * Creates the Lit Action module code
 * @param {object} params - Parameters
 * @param {string} params.ipfsCid - The IPFS CID
 * @param {string} params.content - The content
 * @returns {string} The Lit Action module code
 */
function litActionModuleCode({ ipfsCid, content }) {
  return `/**
* DO NOT EDIT THIS FILE. IT IS GENERATED ON BUILD.
* @type {string}
*/
const code = ${JSON.stringify(content)};
module.exports = {
  "code": code,
  "ipfsCid": "${ipfsCid}",
};
`;
}

/**
 * Creates the metadata JSON file
 * @param {object} params - Parameters
 * @param {string} params.ipfsCid - The IPFS CID
 * @returns {string} The metadata JSON
 */
function metadataJsonFile({ ipfsCid }) {
  return `{
  "ipfsCid": "${ipfsCid}"
}
`;
}

/**
 * Creates a plugin to create the bundled file (ability or policy)
 * @param {string} sourceDir - The source directory
 * @param {string} type - The type of file ('ability' or 'policy')
 * @returns {object} esbuild plugin
 */
function createBundledFile(sourceDir, type) {
  if (type !== 'ability' && type !== 'policy') {
    throw new Error(`Invalid type: ${type}. Must be 'ability' or 'policy'`);
  }

  return {
    name: `create-vincent-bundled-${type}-file`,
    setup(build) {
      build.initialOptions.write = false;

      build.onEnd(async (result) => {
        if (result.errors.length > 0) {
          console.error('Build failed with errors:', result.errors);
          return;
        }

        const outputFile = result.outputFiles[0];
        const content = outputFile.text;
        const ipfsCid = await Hash.of(content);

        // Write bundled wrapper
        // Get the output directory path
        const outputPath = path.dirname(path.resolve(outputFile.path));
        // Calculate the relative path from the output directory to the source directory
        const relativePathToSourceDir = path.relative(outputPath, sourceDir);
        // Construct the path to the vincent-ability/policy.ts file relative to the output directory
        const vincentPath = path.join(relativePathToSourceDir, `vincent-${type}`);
        // Generate the bundled source code with the computed relative path
        const bundledSource =
          type === 'ability'
            ? getBundledVincentAbilityCode(ipfsCid, vincentPath)
            : getBundledVincentPolicyCode(ipfsCid, vincentPath);

        // Use the output path to determine the bundled path
        const bundledPath = path.join(outputPath, `vincent-bundled-${type}.ts`);

        ensureDirectoryExistence(bundledPath);
        fs.writeFileSync(bundledPath, bundledSource);

        // Write metadata JSON
        // Use the directory of the generated output file
        const metadataPath = path.join(outputPath, `vincent-${type}-metadata.json`);
        const metadataContent = metadataJsonFile({ ipfsCid });
        ensureDirectoryExistence(metadataPath);
        fs.writeFileSync(metadataPath, metadataContent);
      });
    },
  };
}

/**
 * Creates a plugin to wrap IIFE in string
 * @returns {object} esbuild plugin
 */
const wrapIIFEInStringPlugin = {
  name: 'wrap-iife-in-string',
  setup(build) {
    build.initialOptions.write = false;

    build.onEnd(async (result) => {
      if (result.errors.length > 0) {
        console.error('Build failed with errors:', result.errors);
        return;
      }

      const outputFile = result.outputFiles[0];
      const content = outputFile.text;
      const ipfsCid = await Hash.of(content);

      const wrapped = litActionModuleCode({ content, ipfsCid });

      // Use the path from the generated output file
      const outputPath = path.resolve(outputFile.path);

      ensureDirectoryExistence(outputPath);
      fs.writeFileSync(outputPath, wrapped);
    });
  },
};

/**
 * Builds a Vincent Lit Action (ability or policy)
 * @param {object} options - Build options
 * @param {string} options.entryPoint - The entry point file
 * @param {string} options.outdir - The output directory
 * @param {string} options.tsconfigPath - Path to tsconfig.json
 * @param {string} options.type - Type of the bundle ('ability' or 'policy')
 * @returns {Promise<void>}
 */
async function buildVincentLitAction({ entryPoint, outdir, tsconfigPath, type }) {
  try {
    const sourceDir = path.dirname(entryPoint);

    await esbuild
      .build({
        outdir,
        tsconfig: tsconfigPath,
        entryPoints: [entryPoint],
        bundle: true,
        minify: false,
        sourcemap: false,
        treeShaking: true,
        metafile: true,
        plugins: [
          aliasFetch(path.resolve(__dirname, 'deno-fetch-shim.js')),
          polyfillNode({
            globals: {
              Buffer: true,
              process: true,
            },
            modules: {
              crypto: true,
              http: true,
              https: true,
              stream: true,
              zlib: true,
              url: true,
              util: true,
            },
          }),
          wrapIIFEInStringPlugin,
          createBundledFile(sourceDir, type),
        ],
        platform: 'browser',
        write: false,
      })
      .then((result) => {
        result.outputFiles.forEach((file) => {
          const bytes = file.text.length;
          const mbInDecimal = (bytes / 1_000_000).toFixed(4);

          const filePathArr = file.path.split('/');
          console.log(
            `‚úÖ ${type === 'ability' ? 'üõ†Ô∏è' : '‚öñÔ∏è'}${filePathArr.slice(filePathArr.length - 2, filePathArr.length - 1)} - ${mbInDecimal} MB`,
          );
        });
      });
  } catch (e) {
    console.error(`‚ùå Error building Vincent ${type}:`, e.message, e.stack);
  }
}

/**
 * Builds a Vincent ability
 * @param {object} options - Build options
 * @param {string} options.entryPoint - The entry point file
 * @param {string} options.outdir - The output directory
 * @param {string} options.tsconfigPath - Path to tsconfig.json
 * @returns {Promise<void>}
 */
async function buildVincentAbility({ entryPoint, outdir, tsconfigPath }) {
  return buildVincentLitAction({
    entryPoint,
    outdir,
    tsconfigPath,
    type: 'ability',
  });
}

/**
 * Builds a Vincent policy
 * @param {object} options - Build options
 * @param {string} options.entryPoint - The entry point file
 * @param {string} options.outdir - The output directory
 * @param {string} options.tsconfigPath - Path to tsconfig.json
 * @returns {Promise<void>}
 */
async function buildVincentPolicy({ entryPoint, outdir, tsconfigPath }) {
  return buildVincentLitAction({
    entryPoint,
    outdir,
    tsconfigPath,
    type: 'policy',
  });
}

module.exports = {
  buildVincentAbility,
  buildVincentPolicy,
};
