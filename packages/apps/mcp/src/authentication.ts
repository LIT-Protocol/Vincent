import { LIT_EVM_CHAINS } from '@lit-protocol/constants';
import { jwt } from '@lit-protocol/vincent-app-sdk';
import { SiweMessage } from 'siwe';

import { nonceManager } from './nonceManager';

import { env } from './env';

const { EXPECTED_AUDIENCE, SIWE_EXPIRATION_TIME, VINCENT_MCP_BASE_URL } = env;
const { verify } = jwt;

const YELLOWSTONE = LIT_EVM_CHAINS.yellowstone;

if (!EXPECTED_AUDIENCE || !VINCENT_MCP_BASE_URL) {
  throw new Error(
    '"EXPECTED_AUDIENCE" or "VINCENT_MCP_BASE_URL" environment variable missing. They are required for proper authentication',
  );
}

/**
 * Generates a SIWE (Sign-In with Ethereum) message for authentication.
 * This message needs to be signed by the user's wallet to prove ownership of the address.
 *
 * @param {string} address - The Ethereum address that will be used for authentication
 * @returns {string} The prepared SIWE message ready to be signed by the user's wallet
 */
export function getSiweMessageToAuthenticate(address: string) {
  const nonce = nonceManager.getNonce(address);

  const message = new SiweMessage({
    address,
    chainId: YELLOWSTONE.chainId,
    domain: VINCENT_MCP_BASE_URL,
    expirationTime: new Date(Date.now() + SIWE_EXPIRATION_TIME).toISOString(),
    issuedAt: new Date().toISOString(),
    nonce,
    statement: 'Sign in as delegatee to the Vincent MCP.',
    uri: EXPECTED_AUDIENCE,
    version: '1',
  });

  return message.prepareMessage();
}

/**
 * Verifies a SIWE (Sign-In with Ethereum) message and signature.
 * Validates the signature, nonce, domain, and audience before authenticating the user.
 *
 * @param {string} messageToSign - The original SIWE message that was signed
 * @param {string} signature - The signature generated by signing the message with the user's wallet
 * @returns {Promise<string>} The verified Ethereum address if authentication is successful
 * @throws {Error} If the SIWE message verification fails for any reason
 */
export async function authenticateWithSiwe(
  messageToSign: string,
  signature: string,
): Promise<string> {
  const siweMsg = new SiweMessage(messageToSign);
  const verification = await siweMsg.verify({ domain: VINCENT_MCP_BASE_URL, signature });

  const { address, expirationTime, issuedAt, nonce, uri } = verification.data;

  if (
    !verification.success ||
    !issuedAt ||
    !expirationTime ||
    !nonceManager.consumeNonce(address, nonce) ||
    new Date(issuedAt).getTime() + SIWE_EXPIRATION_TIME >= new Date(expirationTime).getTime() ||
    uri !== EXPECTED_AUDIENCE
  ) {
    throw new Error('SIWE message verification failed');
  }

  return address;
}

/**
 * Authenticates a request using a JWT token. This method is specifically for delegator authentication.
 * Verifies the JWT signature and validates the app ID and version.
 *
 * @param {string} jwt - The JSON Web Token to verify
 * @param {string} appId - The expected application ID that should match the JWT payload
 * @param {string} appVersion - The expected application version that should match the JWT payload
 * @returns {string} The Ethereum address of the PKP (Programmable Key Pair) from the JWT payload
 * @throws {Error} If the JWT is invalid or doesn't match the expected app ID/version
 */
export function authenticateWithJwt(jwt: string, appId: string, appVersion: string): string {
  // @ts-expect-error Env var is defined or this module would have thrown
  const decodedJwt = verify(jwt, EXPECTED_AUDIENCE);
  const { id, version } = decodedJwt.payload.app;
  if (id !== appId || version !== parseInt(appVersion)) {
    throw new Error('JWT provided is not valid for this Vincent App MCP');
  }

  return decodedJwt.payload.pkp.ethAddress;
}
